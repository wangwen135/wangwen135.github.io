<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wangwen135.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
<meta property="og:type" content="website">
<meta property="og:title" content="王某某的笔记">
<meta property="og:url" content="https://wangwen135.github.io/page/7/index.html">
<meta property="og:site_name" content="王某某的笔记">
<meta property="og:description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="王某某">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wangwen135.github.io/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>王某某的笔记</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBG120GJ9P","only_pageview":true,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">王某某的笔记</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录我的编程之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="王某某"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">王某某</p>
  <div class="site-description" itemprop="description">这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">146</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wangwen135" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangwen135" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/66c41e72644b" title="简  书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;66c41e72644b" rel="noopener me" target="_blank"><i class="fa fa-link fa-fw"></i>简  书</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangwen135@gmail.com" title="E-Mail → mailto:wangwen135@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/wangwen135" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;wangwen135" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/" class="post-title-link" itemprop="url">浮点类型是如何存储的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-08T00:00:00+08:00">2020-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="计算机如何存储字节"><a href="#计算机如何存储字节" class="headerlink" title="计算机如何存储字节"></a>计算机如何存储字节</h2><p>计算机中最小的存储单位是bit只能保存0和1，整数在内存中如何存储我们都知道，将要存储的数字转成2进制即可</p>
<p>用windows自带的计数器可以方便的查看整数对应的2进制值<br>如：<br>byte类型（单字节）</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>0000 1000</td>
</tr>
<tr>
<td>9</td>
<td>0000 1001</td>
</tr>
<tr>
<td>100</td>
<td>0110 0100</td>
</tr>
<tr>
<td>-5</td>
<td>1111 1011</td>
</tr>
<tr>
<td>-8</td>
<td>1111 1000</td>
</tr>
</tbody></table>
<blockquote>
<p>第一位为符号位，负数等于正数取反 +1</p>
</blockquote>
<p>那浮点类型是如何用这么少的字节（如float 4字节）表示这么大（float 最大 3.4028235E38）的数字呢？</p>
<h2 id="浮点类型是如何存储的"><a href="#浮点类型是如何存储的" class="headerlink" title="浮点类型是如何存储的"></a>浮点类型是如何存储的</h2><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数，是属于有理数中某特定子集的数的数字表示，在计算机中用以近似表示任意某个实数。具体的说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到，这种表示方法类似于基数为10的科学计数法。</p>
<h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p>科学计数法是一种记数的方法。把一个数表示成a与10的n次幂相乘的形式（1≤|a|&lt;10，a不为分数形式，n为整数），这种记数法叫做科学计数法。当我们要标记或运算某个较大或较小且位数较多时，用科学计数法免去浪费很多空间和时间。</p>
<h3 id="java中的浮点数字遵循-IEEE-754-标准"><a href="#java中的浮点数字遵循-IEEE-754-标准" class="headerlink" title="java中的浮点数字遵循 IEEE 754 标准"></a>java中的浮点数字遵循 IEEE 754 标准</h3><p>这也是一种目前最常用的浮点数标准！为许多CPU与浮点运算器所采用。</p>
<p>简单的说就是将一个浮点数字拆成3个部分（符号部分、指数部分、小数部分） 存储在连续的bit中，类似科学计数法。</p>
<p>用 {S，E，M}来表示一个数 V 的，即 <strong>V &#x3D;（-1）S × M × 2E</strong>，如下：</p>
<table>
<thead>
<tr>
<th>S（符号位）</th>
<th>E（指数位）</th>
<th>M（有效数字位）</th>
</tr>
</thead>
</table>
<p>其中：</p>
<ul>
<li>符号位 s（Sign）决定数是正数（s＝0）还是负数（s＝1），而对于数值 0 的符号位解释则作为特殊情况处理。</li>
<li>有效数字位 M（Significand）是二进制小数，它的取值范围为 0~1 。它也被称为尾数位（Mantissa）、系数位（Coefficient），甚至还被称作“小数”。</li>
<li>指数位 E（Exponent）是 2 的幂（可能是负数，为了表示负数实际指数需要加一个偏移量），它的作用是对浮点数加权。</li>
</ul>
<h3 id="IEEE-754浮点数规范"><a href="#IEEE-754浮点数规范" class="headerlink" title="IEEE 754浮点数规范"></a>IEEE 754浮点数规范</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+- d.ddd...d * β^e   (0 &lt;= di &lt; β)  </span><br></pre></td></tr></table></figure>

<p>其中d.dd…d 为有效数字，β为基数，e 为指数</p>
<p>有效数字中 数字的个数 称为<strong>精度</strong>，我们可以用 p 来表示，即可称为 p 位有效数字精度。<br>每个数字 d 介于 <strong>0</strong> 和基数 <strong>β</strong> 之间，包括 0。</p>
<h4 id="十进制表示"><a href="#十进制表示" class="headerlink" title="十进制表示"></a>十进制表示</h4><p>对十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解。<br>如 12.34，我们可以根据上面的表达式表达为：<br><strong>1×10<sup>1</sup> + 2×10<sup>0</sup> + 3×10<sup>-1</sup> + 4×10<sup>-2</sup></strong><br>其规范的浮点数表达为：**1.234×10<sup>1</sup>**。</p>
<h4 id="二进制表示"><a href="#二进制表示" class="headerlink" title="二进制表示"></a>二进制表示</h4><p>但对二进制来说，上面的表达式同样可以简单地表达。<br>唯一不同之处在于：二进制的 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。  </p>
<p>如二进制数 <strong>1001.101</strong>，我们可以根据上面的表达式表达为：<br><strong>1×2<sup>3</sup> + 0×2<sup>2</sup> + 0×2<sup>1</sup> + 1×2<sup>0</sup> + 1×2<sup>-1</sup> + 0×2<sup>-2</sup> + 1×2<sup>-3</sup></strong><br>其规范浮点数表达为：**1.001101×2<sup>3</sup>**。</p>
<h3 id="二进制转换为十进制"><a href="#二进制转换为十进制" class="headerlink" title="二进制转换为十进制"></a>二进制转换为十进制</h3><p>二进制数 1001.101 转成十进制如下：</p>
<blockquote>
<p> &#x3D; 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 0 × 2<sup>1</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>-1</sup> + 0 × 2<sup>-2</sup> + 1×2<sup>-3</sup><br> &#x3D; 8 + 0 + 0 + 1 + 1&#x2F;2 + 0 + 1&#x2F;8<br> &#x3D; 9又1&#x2F;8 (9又8分之1)<br> &#x3D; 9.625  </p>
</blockquote>
<p>由上面的等式，我们可以得出：<br>向左移动二进制小数点一位相当于这个数除以 2，而向右移动二进制小数点一位相当于这个数乘以 2。<br>如 101.11 &#x3D; 5又3&#x2F;4  (5.75)，向左移动一位，得到 10.111 &#x3D; 2又7&#x2F;8 （2.875）。</p>
<p>除此之外，我们还可以得到这样一个基本规律：<br>一个十进制小数要能用浮点数精确地表示，最后一位必须是 5（当然这是必要条件，并非充分条件）。<br>如下面的示例所示：</p>
<table>
<thead>
<tr>
<th>二进制小数</th>
<th>2的多少次方</th>
<th>十进制的小数</th>
</tr>
</thead>
<tbody><tr>
<td>0.1</td>
<td>2<sup>-1</sup></td>
<td>0.5</td>
</tr>
<tr>
<td>0.01</td>
<td>2<sup>-2</sup></td>
<td>0.25</td>
</tr>
<tr>
<td>0.001</td>
<td>2<sup>-3</sup></td>
<td>0.125</td>
</tr>
<tr>
<td>0.0001</td>
<td>2<sup>-4</sup></td>
<td>0.0625</td>
</tr>
<tr>
<td>0.00001</td>
<td>2<sup>-5</sup></td>
<td>0.03125</td>
</tr>
<tr>
<td>0.000001</td>
<td>2<sup>-6</sup></td>
<td>0.015625</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="十进制转换为二进制"><a href="#十进制转换为二进制" class="headerlink" title="十进制转换为二进制"></a>十进制转换为二进制</h3><p>基本换算方法：<br>将10进制的数拆分成整数和小数两个部分<br>整数部分除以2，取余数；小数部分乘以2，取整数位。  </p>
<p>示例：<br>将十进制 1.1 转成 二进制</p>
<p><strong>整数部分：1</strong><br>1 </p>
<p><strong>小数部分：0.1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0.1 *2 = 0.2 -&gt; 0</span><br><span class="line">0.2 *2 = 0.4 -&gt; 0</span><br><span class="line">0.4 *2 = 0.8 -&gt; 0</span><br><span class="line">0.8 *2 = 1.6 -&gt; 1</span><br><span class="line">0.6 *2 = 1.2 -&gt; 1</span><br><span class="line">0.2 *2 = 0.4 -&gt; 0</span><br><span class="line">0.4 *2 = 0.8 -&gt; 0</span><br><span class="line">0.8 *2 = 1.6 -&gt; 1</span><br><span class="line">0.6 *2 = 1.2 -&gt; 1</span><br><span class="line">0.2 *2 = 0.4 -&gt; 0</span><br><span class="line">0.4 *2 = 0.8 -&gt; 0</span><br><span class="line">0.8 *2 = 1.6 -&gt; 1</span><br><span class="line">0.6 *2 = 1.2 -&gt; 1</span><br><span class="line">0.2 *2 = 0.4 -&gt; 0</span><br><span class="line">0.4 *2 = 0.8 -&gt; 0</span><br><span class="line">0.8 *2 = 1.6 -&gt; 1</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>二进制形式表示为：<br>1.000110011001100110011…</p>
<h4 id="再将上面的数换算成10进制"><a href="#再将上面的数换算成10进制" class="headerlink" title="再将上面的数换算成10进制"></a>再将上面的数换算成10进制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 + 1/16 + 1/32 + 1/256 + 1/512  + ...</span><br><span class="line">约等于  </span><br><span class="line">（32 + 16 + 2 + 1）/512    </span><br><span class="line">约等于  </span><br><span class="line">  51/512  </span><br><span class="line">约等于  </span><br><span class="line">  0.099609375</span><br></pre></td></tr></table></figure>

<p>再加上整数1，约等于：<br><strong>1.099609375</strong>  </p>
<p><strong>计算的位数越多越精确</strong></p>
<p><strong>注意：</strong><br>二进制小数不像整数一样，只要位数足够，它就可以表示所有整数。<br>在有限长度的编码中，二进制小数一般无法精确的表示任意小数，比如十进制小数0.2，我们并不能将其准确的表示为一个二进制数，只能增加二进制长度提高表示的精度。</p>
<blockquote>
<p>十进制的0.2 转换成二进制为：0.00110011001100110011001100110011001100110011001100110……</p>
</blockquote>
<hr>
<h3 id="java-API-中对Double-和-Float-类型的描述"><a href="#java-API-中对Double-和-Float-类型的描述" class="headerlink" title="java API 中对Double 和 Float 类型的描述"></a>java API 中对Double 和 Float 类型的描述</h3><h4 id="Double-双精度浮点数-64bit-（8byte）"><a href="#Double-双精度浮点数-64bit-（8byte）" class="headerlink" title="Double 双精度浮点数 64bit （8byte）"></a>Double 双精度浮点数 64bit （8byte）</h4><p>根据 IEEE 754 浮点“双精度格式”位布局。 </p>
<ul>
<li>第 63 位（掩码 0x8000000000000000L 选定的位）表示浮点数的符号。</li>
<li>第 62-52 位（掩码 0x7ff0000000000000L 选定的位）表示指数。</li>
<li>第 51-0 位（掩码 0x000fffffffffffffL 选定的位）表示浮点数的有效数字（有时也称为尾数）。</li>
</ul>
<p>如果参数是正无穷大，则结果为 0x7ff0000000000000L。<br>如果参数是负无穷大，则结果为 0xfff0000000000000L。<br>如果参数是 NaN，则结果为 0x7ff8000000000000L。   </p>
<h4 id="Float-单精度浮点数-32bit-（4byte）"><a href="#Float-单精度浮点数-32bit-（4byte）" class="headerlink" title="Float 单精度浮点数 32bit （4byte）"></a>Float 单精度浮点数 32bit （4byte）</h4><p>根据 IEEE 754 浮点“单一格式”位布局。 </p>
<ul>
<li>第 31 位（掩码 0x80000000 选定的位）表示浮点数的符号。</li>
<li>第 30-23 位（掩码 0x7f800000 选定的位）表示指数。</li>
<li>第 22-0 位（掩码 0x007fffff 选定的位）表示浮点数的有效位数（有时也称为尾数）。</li>
</ul>
<p>如果参数为正无穷大，则结果为 0x7f800000。<br>如果参数为负无穷大，则结果为 0xff800000。<br>如果参数为 NaN，则结果为 0x7fc00000。 </p>
<h4 id="掩码位说明"><a href="#掩码位说明" class="headerlink" title="掩码位说明"></a>掩码位说明</h4><p>这里以 double类型说明</p>
<ul>
<li><p>第 63 位（掩码 0x8000000000000000L 选定的位）表示浮点数的符号。<br> 转成二进制<br> 1000000000000000000000000000000000000000000000000000000000000000</p>
</li>
<li><p>第 62-52 位（掩码 0x7ff0000000000000L 选定的位）表示指数。<br> 转成二进制<br> 0111111111110000000000000000000000000000000000000000000000000000</p>
</li>
<li><p>第 51-0 位（掩码 0x000fffffffffffffL 选定的位）表示浮点数的有效数字（有时也称为尾数）。<br> 转成二进制<br> 0000000000001111111111111111111111111111111111111111111111111111</p>
</li>
</ul>
<p>将一个浮点数与上面的掩码进行与运算，即可得到对应的 符号位、指数位、尾数位 的值。</p>
<blockquote>
<p>这里的多少多少位是从右往左数的，当转成2进制不够64位时在前面补零即可</p>
</blockquote>
<hr>
<h4 id="按照浮点数计算规范要求：（划重点）"><a href="#按照浮点数计算规范要求：（划重点）" class="headerlink" title="按照浮点数计算规范要求：（划重点）"></a>按照浮点数计算规范要求：（划重点）</h4><ul>
<li>符号为 1表示负数，0表示正数</li>
<li>指数 &#x3D;（为了表示负指数，实际的指数需要加上一个值，双精度为 2e10-1 &#x3D; 1023）&#x3D; <strong>实际指数 + 1023</strong></li>
<li>有效数字省略了最高的一位1，<strong>去掉小数点左侧的 1</strong>，并用 0 在右侧补齐。</li>
</ul>
<h5 id="故前面十进制数-1-1-的二进制形式："><a href="#故前面十进制数-1-1-的二进制形式：" class="headerlink" title="故前面十进制数(1.1)的二进制形式："></a>故前面十进制数(1.1)的二进制形式：</h5><p><strong>1.000110011001100110011…</strong></p>
<h5 id="用浮点类型表示："><a href="#用浮点类型表示：" class="headerlink" title="用浮点类型表示："></a>用浮点类型表示：</h5><ul>
<li>符号位：0</li>
<li>指数为：0 + 1023 &#x3D; 1111111111 &#x3D; (不够11位前面补0) &#x3D; 01111111111</li>
<li>有效位：000110011001100110011…</li>
</ul>
<p>所以存为：<br><strong>0 01111111111 000110011001100110011…</strong></p>
<h4 id="用java代码输出进行验证"><a href="#用java代码输出进行验证" class="headerlink" title="用java代码输出进行验证"></a>用java代码输出进行验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(1.1)));</span><br><span class="line">//11111111110001100110011001100110011001100110011001100110011010</span><br><span class="line">//这种情况前面要补两个0</span><br><span class="line">//0011111111110001100110011001100110011001100110011001100110011010</span><br><span class="line"></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(-1.1)));</span><br><span class="line">//1011111111110001100110011001100110011001100110011001100110011010</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h2><p>根据 IEEE 754 规范</p>
<ul>
<li>Float 单精度浮点数，有效位数只有23 bit位</li>
<li>Double 双精度浮点数，有效位数只有52 bit位</li>
</ul>
<p>在二进制，第一个有效数字必定是“1”，因此这个“1”并不会存储。<br>单精和双精浮点数的有效数字分别是有存储的23和52个位，加上最左边没有存储的第1个位，即是24和53个位。  </p>
<p>通过计算其能表示的最大值，换十进制来看其精度：</p>
<ul>
<li><p>Float<br>二进制的24个1 &#x3D;&gt; （二进制） 111111111111111111111111 &#x3D;&gt; （计算） 2^24 - 1  &#x3D;&gt; (十进制) 16777215 &#x3D;&gt; （Float 精度最大8位数）</p>
</li>
<li><p>Double<br>二进制的53个1 &#x3D;&gt; （二进制） 11111111111111111111111111111111111111111111111111111 &#x3D;&gt; （计算）2^53 - 1 &#x3D;&gt; （十进制）9007199254740991 &#x3D;&gt; (Double 精度最大16位数)</p>
</li>
</ul>
<h3 id="为什么会丢失精度"><a href="#为什么会丢失精度" class="headerlink" title="为什么会丢失精度"></a>为什么会丢失精度</h3><p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。而往往产生误差不是因为数的大小，而是因为数的精度。</p>
<p>我自己理解为分两种情况（这个不一定是对）</p>
<ol>
<li>当有小数时，浮点数本身就不能精确记录其数值，只记了一个近似值，此时进行计算就很可能不对</li>
<li>有效位数不够用了，导致舍入</li>
</ol>
<h4 id="1、不能精确记录其数值"><a href="#1、不能精确记录其数值" class="headerlink" title="1、不能精确记录其数值"></a>1、不能精确记录其数值</h4><p>通过上面的转换示例，我们知道小数的二进制表示一般都不是精确的，在有限的精度下只能尽量的表示近似值</p>
<p>值本身就不是精确的，再进行计算就很可能产生误差</p>
<h5 id="0-1-0-2-0-30000000000000004"><a href="#0-1-0-2-0-30000000000000004" class="headerlink" title="0.1+0.2&#x3D;0.30000000000000004"></a>0.1+0.2&#x3D;0.30000000000000004</h5><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">double d1 = 0.1;</span><br><span class="line">double d2 = 0.2;</span><br><span class="line">double d3 = d1 + d2;</span><br><span class="line">System.out.println(d3);</span><br><span class="line">System.out.println(&quot;######################################&quot;);</span><br><span class="line">System.out.println(new BigDecimal(d1));</span><br><span class="line">System.out.println(new BigDecimal(d2));</span><br><span class="line">System.out.println(new BigDecimal(d3));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;######################################&quot;);</span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(d1)));</span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(d2)));</span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(d3)));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0.30000000000000004</span><br><span class="line">######################################</span><br><span class="line">0.1000000000000000055511151231257827021181583404541015625</span><br><span class="line">0.200000000000000011102230246251565404236316680908203125</span><br><span class="line">0.3000000000000000444089209850062616169452667236328125</span><br><span class="line">######################################</span><br><span class="line">11111110111001100110011001100110011001100110011001100110011010</span><br><span class="line">11111111001001100110011001100110011001100110011001100110011010</span><br><span class="line">11111111010011001100110011001100110011001100110011001100110100</span><br></pre></td></tr></table></figure>

<p><strong>0.1</strong><br>原始值： 0 01111111011  1001100110011001100110011001100110011001100110011010<br>指数：1019 -1023 &#x3D; -4<br>二进制形式：<br>0.00011001100110011001100110011001100110011001100110011010</p>
<p><strong>0.2</strong><br>原始值：0 01111111100  1001100110011001100110011001100110011001100110011010<br>指数：1020 -1023 &#x3D; -3<br>二进制形式：<br>0.001001100110011001100110011001100110011001100110011010</p>
<p><strong>0.3</strong><br>原始值：0 01111111101  0011001100110011001100110011001100110011001100110100<br>指数：1021 &#x3D; -2<br>二进制形式：<br>0.010011001100110011001100110011001100110011001100110100</p>
<p><strong>二进制加法运算</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.00011001100110011001100110011001100110011001100110011010</span><br><span class="line">+</span><br><span class="line">0.001001100110011001100110011001100110011001100110011010</span><br><span class="line">=</span><br><span class="line">0.010011001100110011001100110011001100110011001100110100</span><br></pre></td></tr></table></figure>

<h5 id="其他示例："><a href="#其他示例：" class="headerlink" title="其他示例："></a>其他示例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">double a = 0.03;</span><br><span class="line">double b = 0.01;</span><br><span class="line">System.out.println(a - b); </span><br><span class="line">//结果 0.019999999999999997</span><br><span class="line"></span><br><span class="line">double x = 10.2;</span><br><span class="line">double y = 10.03;</span><br><span class="line">System.out.println(x + y); </span><br><span class="line">//结果 20.229999999999997</span><br><span class="line"></span><br><span class="line">double dx = 1.099999999999999999999999999999d;</span><br><span class="line">System.out.println(dx);</span><br><span class="line">//结果 1.1</span><br><span class="line"></span><br><span class="line">double dy = 1.1000000000000000000000000000001d;</span><br><span class="line">System.out.println(dy);</span><br><span class="line">//结果 1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2、有效位数不够用"><a href="#2、有效位数不够用" class="headerlink" title="2、有效位数不够用"></a>2、有效位数不够用</h4><p>这里用float验证，float最大的精度是8位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 有效位数不够</span><br><span class="line">float f = 1.23456789f;</span><br><span class="line">System.out.println(f);   // 1.2345679   最大只能有8位</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;=====================&quot;);</span><br><span class="line">float f1 = 10000f;</span><br><span class="line">System.out.println(f1);  // 10000.0</span><br><span class="line">float f2 = 1.123456f;</span><br><span class="line">System.out.println(f2);  // 1.123456</span><br><span class="line"></span><br><span class="line">// 相加之后有效位数不够</span><br><span class="line">float f3 = f1 + f2;</span><br><span class="line">System.out.println(f3);  // 10001.123   位数不够，后面的被省略了</span><br></pre></td></tr></table></figure>

<h3 id="关于舍入"><a href="#关于舍入" class="headerlink" title="关于舍入"></a>关于舍入</h3><p>对于不能精确的表示的数，采取一种系统的方法：找到“最接近”的匹配值，它可以用期望的浮点形式表现出来，这就是舍入。</p>
<p>对于舍入，可以有很多种规则，可以向上舍入，向下舍入，向偶数舍入。如果我们只采用前两种中的一种，就会造成平均数过大或者过小，实际上这时候就是引入了统计偏差。如果是采用偶数舍入，则有一半的机会是向上舍入，一半的机会是向下舍入，这样子可以避免统计偏差。而 IEEE 754 就是采用向最近偶数舍入（round to nearest even）的规则。</p>
<p>（这段是网上抄的）</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="大端-小端问题"><a href="#大端-小端问题" class="headerlink" title="大端 小端问题"></a>大端 小端问题</h3><p><strong>这里以java语言示例，用大端的方式示例（网络序）</strong></p>
<p>java中是以大端模式存储的，java对我们屏蔽了内部字节顺序的问题以实现跨平台！</p>
<p>实际在不同的cpu架构下，存储方式不同，我们常用的X86是以小端的模式存储的。</p>
<p>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。</p>
<hr>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><h4 id="二进制字符串转成Double"><a href="#二进制字符串转成Double" class="headerlink" title="二进制字符串转成Double"></a>二进制字符串转成Double</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 4607632778762754458</span><br><span class="line">    String s = &quot;0011111111110001100110011001100110011001100110011001100110011010&quot;;</span><br><span class="line">    System.out.println(&quot;二进制字符串 = &quot; + s);</span><br><span class="line">    long l = Long.parseLong(s, 2);</span><br><span class="line">    System.out.println(&quot;转成Long = &quot; + l);</span><br><span class="line">    double d = Double.longBitsToDouble(l);</span><br><span class="line">    System.out.println(&quot;再将Long转成Double = &quot; + d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二进制字符串 = 0011111111110001100110011001100110011001100110011001100110011010</span><br><span class="line">转成Long = 4607632778762754458</span><br><span class="line">再将Long转成Double = 1.1</span><br></pre></td></tr></table></figure>

<h4 id="写内存的方式转Double"><a href="#写内存的方式转Double" class="headerlink" title="写内存的方式转Double"></a>写内存的方式转Double</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * bit字符串转Double</span><br><span class="line"> * </span><br><span class="line"> * @param bitStr 64位的01字符串</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">public static void bit2Double(String bitStr) throws Exception &#123;</span><br><span class="line">    String[] array = splitString(bitStr, 8);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    long address = unsafe.allocateMemory(8L);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        String bits = array[i];</span><br><span class="line">        byte bt = (byte) Integer.parseInt(bits, 2);</span><br><span class="line">        // 因为实际上是小端模式存储的，所以这里从后面开始写入</span><br><span class="line">        unsafe.putByte(address + (7 - i), (byte) bt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long lVal = unsafe.getLong(address);</span><br><span class="line">    System.out.println(&quot;对应的long值是：&quot; + lVal);</span><br><span class="line">    System.out.println(Long.toBinaryString(lVal));</span><br><span class="line"></span><br><span class="line">    double dVal = unsafe.getDouble(address);</span><br><span class="line">    System.out.println(&quot;转成Double 类型是：&quot; + dVal);</span><br><span class="line">    System.out.println(Long.toBinaryString(Double.doubleToLongBits(dVal)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String[] splitString(String source, int length) &#123;</span><br><span class="line">    String[] array = new String[length];</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        array[i] = source.substring(i * length, (i + 1) * length);</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Unsafe getUnsafe() throws Exception &#123;</span><br><span class="line">    Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">    f.setAccessible(true);</span><br><span class="line">    Unsafe unsafe = (Unsafe) f.get(null);</span><br><span class="line">    return unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/" class="post-title-link" itemprop="url">大端和小端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-06T00:00:00+08:00">2020-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p><strong>字节顺序</strong>，又称之为：<strong>端序</strong> 或 <strong>尾序</strong>。在计算机科学领域中指的是：电脑内存 或者在网络通讯链路中，由多个字节组成的<strong>字</strong>的排列方式。</p>
<p>由于不同架构的CPU处理多个字节数据的顺序不一样，比如x86的是小段端模式，KEIL C51是大端模式。但是后来互联网流行，TCP&#x2F;IP协议规定为大端模式，又称为：network order。</p>
<h3 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h3><p>在计算机体系中我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。<br>在编程语言中一个long类型占32bit，那就需要4个字节来存储，那按照什么样的顺序将这四个字节写到内存中？<br>因此就出现了大端存储模式和小端存储模式。</p>
<p><strong>大端（Big-Endian）：</strong>  数据的高位字节在前（内存的低地址），低位字节在后。这样的存储模式类似于把数据当做字符串处理，内存地址由小到大增长，而数据从高位字节开始写入。  </p>
<blockquote>
<p>这种方式符合人类的阅读习惯！</p>
</blockquote>
<p><strong>小端（Little-Endian）：</strong> 数据的低位字节在前（内存的低地址），高位字节在后。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p>
<p>示例：</p>
<blockquote>
<p>如：<br>32位的16进制数：0x1A2B3C4D  在内存中的存储</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内存地址： 00  01  02  03</span><br><span class="line">------------------------------</span><br><span class="line">小端模式： 4D  3C  2B  1A</span><br><span class="line">大端模式： 1A  2B  3C  4D</span><br></pre></td></tr></table></figure>


<h3 id="java中的大端和小端"><a href="#java中的大端和小端" class="headerlink" title="java中的大端和小端"></a>java中的大端和小端</h3><p>Java二进制文件中的所有内容均按大端顺序存储。这种存储方式也被称为network order。这意味着，如果仅仅是用java，则在所有的平台上（如Mac、 PC、 UNIX等）<br>所有文件的处理方式都相同，可以自由的进行二进制文件的交换，而无需担心字节顺序的问题。  </p>
<p>java对我们隐藏了内部字节顺序的问题！</p>
<p>但是当我们与某些不是用Java编写的使用小端顺序的程序交换数据文件时，就会出现问题。最常见的是使用C编写的程序。某些平台在内部使用大端顺序（Mac，IBM 390），有些使用小端序（Intel）。  </p>
<p>C语言默认是小端模式。<br>如果java 要读取C 写的二进制文件，就要涉及到大小端转换的问题。</p>
<hr>
<h3 id="java代码测试"><a href="#java代码测试" class="headerlink" title="java代码测试"></a>java代码测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void printSystemInfo() &#123;</span><br><span class="line">	System.out.println(&quot;##########################################&quot;);</span><br><span class="line">	System.out.println(&quot;系统名称：&quot; + System.getProperty(&quot;os.name&quot;));</span><br><span class="line">	System.out.println(&quot;系统架构：&quot; + System.getProperty(&quot;os.arch&quot;));</span><br><span class="line">	System.out.println(&quot;系统版本：&quot; + System.getProperty(&quot;os.version&quot;));</span><br><span class="line">	System.out.println(&quot;##########################################&quot;);</span><br><span class="line">	System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Unsafe getUnsafe() throws Exception &#123;</span><br><span class="line">	Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">	f.setAccessible(true);</span><br><span class="line">	Unsafe unsafe = (Unsafe) f.get(null);</span><br><span class="line">	return unsafe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">	printSystemInfo();</span><br><span class="line">	try &#123;</span><br><span class="line">		Unsafe UNSAFE = getUnsafe();</span><br><span class="line"></span><br><span class="line">		int intVal = 0x1A2B3C4D;</span><br><span class="line">		System.out.println(&quot;原始值：十六进制：&quot; + Integer.toHexString(intVal) + &quot;  对应十进制：&quot; + intVal);</span><br><span class="line"></span><br><span class="line">		// 分配4个字节的内存</span><br><span class="line">		long address = UNSAFE.allocateMemory(4);</span><br><span class="line">		// 存放int类型的数据，占4个字节</span><br><span class="line">		UNSAFE.putInt(address, intVal);</span><br><span class="line">		byte b = UNSAFE.getByte(address);</span><br><span class="line">		// 通过getByte方法获取刚才存放的int，取第一个字节</span><br><span class="line">		// 如果是大端，存放顺序 —&gt; 1A,2B,3C,4D，取第一位便是0x1A</span><br><span class="line">		// 如果是小端，存放顺序 —&gt; 4D,3C,2B,1A ，取第一位便是0x4D</span><br><span class="line">		System.out.println(&quot;取到的第一个字节：&quot; + Integer.toHexString(b));</span><br><span class="line">		ByteOrder byteOrder;</span><br><span class="line">		switch (b) &#123;</span><br><span class="line">			case 0x1A:</span><br><span class="line">				System.out.println(&quot;当前使用：大端序&quot;);</span><br><span class="line">				byteOrder = ByteOrder.BIG_ENDIAN;</span><br><span class="line">				break;</span><br><span class="line">			case 0x4D:</span><br><span class="line">				System.out.println(&quot;当前使用：小端序&quot;);</span><br><span class="line">				byteOrder = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				byteOrder = null;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(byteOrder);</span><br><span class="line">		// 这里在X86架构的windows机器上跑，输出结果为：</span><br><span class="line">		// LITTLE_ENDIAN</span><br><span class="line"></span><br><span class="line">		// 然后我们重新从内存中读取int</span><br><span class="line">		int val2 = UNSAFE.getInt(address);</span><br><span class="line">		System.out.println(&quot;重新从内存中读取的值：&quot; + val2);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><h5 id="window平台"><a href="#window平台" class="headerlink" title="window平台"></a>window平台</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##########################################</span><br><span class="line">系统名称：Windows 7</span><br><span class="line">系统架构：amd64</span><br><span class="line">系统版本：6.1</span><br><span class="line">##########################################</span><br><span class="line"></span><br><span class="line">原始值：十六进制：1a2b3c4d  对应十进制：439041101</span><br><span class="line">取到的第一个字节：4d</span><br><span class="line">当前使用：小端序</span><br><span class="line">LITTLE_ENDIAN</span><br><span class="line">重新从内存中读取的值：439041101</span><br></pre></td></tr></table></figure>

<h5 id="linux平台"><a href="#linux平台" class="headerlink" title="linux平台"></a>linux平台</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##########################################</span><br><span class="line">系统名称：Linux</span><br><span class="line">系统架构：amd64</span><br><span class="line">系统版本：2.6.32-642.el6.x86_64</span><br><span class="line">##########################################</span><br><span class="line"></span><br><span class="line">原始值：十六进制：1a2b3c4d  对应十进制：439041101</span><br><span class="line">取到的第一个字节：4d</span><br><span class="line">当前使用：小端序</span><br><span class="line">LITTLE_ENDIAN</span><br><span class="line">重新从内存中读取的值：439041101</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6Hash%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/windows%E4%B8%8B%E5%8F%B3%E9%94%AE%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6Hash%E5%80%BC/" class="post-title-link" itemprop="url">windows下右键查看文件Hash值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-31 22:01:00" itemprop="dateCreated datePublished" datetime="2020-08-31T22:01:00+08:00">2020-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>237</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="CMD命令"><a href="#CMD命令" class="headerlink" title="CMD命令"></a>CMD命令</h3><p><strong>certutil -hashfile filename [MD5|SHA1|SHA256]</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;certutil -hashfile &quot;D:\test\123.txt&quot; MD5</span><br><span class="line">MD5 的 D:\test\123.txt 哈希:</span><br><span class="line">3aed2464da46a2719ff1bf0766d2754f</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br></pre></td></tr></table></figure>

<h3 id="添加“右键-发送到”快速计算校验值"><a href="#添加“右键-发送到”快速计算校验值" class="headerlink" title="添加“右键&gt;发送到”快速计算校验值"></a>添加“右键&gt;发送到”快速计算校验值</h3><ol>
<li><p>在文件夹地址栏输入 <strong>shell:sendto</strong> 进入 “发送到” 引用目录  </p>
</li>
<li><p>新建批处理文件（如：checksum.bat），将下面的代码拷贝至文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@echo OFF</span><br><span class="line">:LOOP</span><br><span class="line">    set index=%1</span><br><span class="line">    if %index%! == ! goto END</span><br><span class="line">	echo.</span><br><span class="line">    echo File   : %index%</span><br><span class="line">    echo.</span><br><span class="line">    set /p=&quot;MD5    : &quot;&lt;nul</span><br><span class="line">    certutil -hashfile &quot;%index%&quot; MD5|findstr /V &quot;MD5&quot;|findstr /V &quot;CertUtil&quot;</span><br><span class="line">    set /p=&quot;SHA1   : &quot;&lt;nul</span><br><span class="line">	certutil -hashfile &quot;%index%&quot; SHA1|findstr /V &quot;SHA1&quot;|findstr /V &quot;CertUtil&quot;</span><br><span class="line">	set /p=&quot;SHA256 : &quot;&lt;nul</span><br><span class="line">	certutil -hashfile &quot;%index%&quot; SHA256|findstr /V &quot;SHA256&quot;|findstr /V &quot;CertUtil&quot;</span><br><span class="line">	shift</span><br><span class="line">	goto LOOP</span><br><span class="line">:END</span><br><span class="line">echo.</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
</li>
<li><p>在资源管理器中，右键需要校验的文件，发送至该文件即可<br>ps：也可将批处理文件放在别处，创建文件的快捷方式，然后将快捷方式移动到引用目录</p>
</li>
</ol>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File   : D:\tools\bin\clear.bat</span><br><span class="line"></span><br><span class="line">MD5    : 98bbdca979f85ee3a491769b89021306</span><br><span class="line">SHA1   : ead014790c1adfdfaf10c5ee701d3e59080a662f</span><br><span class="line">SHA256 : 58969ebe81e0669a2d4a995a9a0c62dcae5a711ea61126ddf8eab868a924112b</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/Netty/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88IO%20Multiplexing%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Netty/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88IO%20Multiplexing%EF%BC%89/" class="post-title-link" itemprop="url">IO多路复用（IO Multiplexing）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-16 23:41:00" itemprop="dateCreated datePublished" datetime="2020-08-16T23:41:00+08:00">2020-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们希望在一个或多个I&#x2F;O条件就绪（即输入已准备好被读取，或者描述符能够接收更多输出）时得到通知。此功能称为I&#x2F;O复用，由select和poll等函数支持。</p>
<p>通常情况下，I&#x2F;O多路复用通常用于网络应用程序：  </p>
<ul>
<li>当客户端处理多个描述符时（通常是交互式输入和网络套接字）</li>
<li>当客户端同时处理多个套接字时（这是可能的，但很少见）</li>
<li>如果TCP服务器同时处理侦听套接字及其连接的套接字</li>
<li>如果服务器同时处理TCP和UDP</li>
<li>如果服务器处理多种服务，并且可能处理多种协议</li>
</ul>
<p>但是I&#x2F;O复用不限于网络编程。</p>
<blockquote>
<p>Unix&#x2F;Linux系统中的所有内容都是文件。每个进程都有一个文件描述符，该描述符指向文件，套接字，设备和其他操作系统对象。</p>
</blockquote>
<blockquote>
<p>我们告诉内核我们对哪些描述符感兴趣（用于读取，写入或异常情况）以及等待多长时间。我们感兴趣的描述符不限于套接字，还可以是任何的描述符。</p>
</blockquote>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>Unix&#x2F;Linux 下可供我们使用的五个I&#x2F;O模型</p>
<ol>
<li>blocking I&#x2F;O 【阻塞I&#x2F;O】</li>
<li>nonblocking I&#x2F;O 【非阻塞I&#x2F;O】</li>
<li>I&#x2F;O multiplexing (select and poll) 【多路复用I&#x2F;O】</li>
<li>signal driven I&#x2F;O (SIGIO) 【信号驱动】</li>
<li>asynchronous I&#x2F;O (the POSIX aio_ functions) 【异步I&#x2F;O，由POSIX规范定义的】</li>
</ol>
<p>输入操作通常有两个不同的阶段：</p>
<ol>
<li>等待数据准备就绪。这涉及等待数据到达网络。数据包到达时，它将被复制到内核中的缓冲区中。</li>
<li>将数据从内核复制到进程。这意味着将（就绪）数据从内核缓冲区复制到我们的应用程序缓冲区中</li>
</ol>
<h3 id="同步IO-异步IO"><a href="#同步IO-异步IO" class="headerlink" title="同步IO&amp;异步IO"></a>同步IO&amp;异步IO</h3><p>根据 POSIX 定义:</p>
<ul>
<li>同步I&#x2F;O操作会阻塞请求进程，直到I&#x2F;O操作完成</li>
<li>异步I&#x2F;O操作不会导致阻塞请求进程</li>
</ul>
<p>按照这种分类，上边5种I&#x2F;O模型中，只有AIO一种是异步的，其他都是同步的。<br>因为其中真正的IO操作(recvfrom 调用) 会阻塞进程，recvfrom 会阻塞等待内核将数据从内核空间复制到应用进程空间, 当赋值完成后, recvfrom 才返回。</p>
<p>但是从我们编程的角度来看，「I&#x2F;O多路复用」和「信号驱动I&#x2F;O」都不会导致我们的进程完全被阻塞，因为在多线程下，阻塞一个线程并不会导致整个进程被阻塞。</p>
<h2 id="I-O多路复用实现方式"><a href="#I-O多路复用实现方式" class="headerlink" title="I&#x2F;O多路复用实现方式"></a>I&#x2F;O多路复用实现方式</h2><p>I&#x2F;O多路复用(I&#x2F;O multiplexing) 通过系统调用 select，poll，epoll 支持。</p>
<p>select&#x2F;epoll的好处就在于单个进程就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这些个函数会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。  </p>
<blockquote>
<p>本质是通过系统函数select、poll、epool（模块）来监听多个文件描述符（套接字描述符）。<br>无论epoll还是select都受限于系统中单个进程能够打开的文件句柄数。</p>
</blockquote>
<p>select&#x2F;poll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<h3 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h3><p>select是个系统调用，提供了一种用于实现同步多路复用I&#x2F;O的机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>对select()的调用将一直阻塞，直到给定的文件描述符准备执行I&#x2F;O为止，或者直到经过可选的指定超时为止。</p>
<p>监视的文件描述符类型分为三种：</p>
<ul>
<li>监视readfds集中列出的文件描述符，以查看是否有数据可读取。</li>
<li>监视writefds集中列出的文件描述符，以查看写操作是否将完成而不会阻塞。</li>
<li>监视exceptionfds集中的文件描述符，以查看是否发生了异常或带外数据是否可用（这些状态仅适用于套接字）。</li>
</ul>
<p>执行select()成功返回后，将修改每个集合，以使其仅包含准备好由该集合描述的I&#x2F;O类型的文件描述符。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>select的主要优点是它具有很高的可移植性-像OS一样的每个UNIX都具有它</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>select()使用fd_set来表示文件描述符的集合，而fd_set其实就是一个固定长度的位向量(bit vector)，在Linux上，这个固定长度是FD_SETSIZE，其数值是1024。<br>故select()监听的文件描述符总数必须小于1024。  </li>
<li>我们需要遍历文件描述符以检查它是否存在于select返回的集合中</li>
</ul>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><p>每次select之前要重置每个入参集合的值（返回时会被修改）。</p>
<h3 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h3><p>poll提供与相似的功能select。<br>与select()不同，因为select()具有效率低下的三个基于位掩码的文件描述符集，poll()使用nfds pollfd结构的单个数组。原型更简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>

<p>pollfd结构的事件和返回事件具有不同的字段，因此我们不必每次都构建它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">      int fd;</span><br><span class="line">      short events; </span><br><span class="line">      short revents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于每个文件描述符，构建一个类型为pollfd的对象，并填充所需的事件。poll返回后，检查revents字段即可</p>
<p>就像我们对select所做的那样，我们需要检查每个pollfd对象以查看其文件描述符是否已准备就绪，但是我们不需要在每次迭代时都构建集合</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>poll()系统调用将输入（events字段）与输出（revents字段）分开，从而允许入参被重复使用而无需更改。</p>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>由于某些Unix系统不支持poll()，因此select()具有更高的可移植性。</p>
<h3 id="select-和-poll-的性能问题"><a href="#select-和-poll-的性能问题" class="headerlink" title="select 和 poll 的性能问题"></a>select 和 poll 的性能问题</h3><p>使用select()或poll()监听大量的文件描述符时，往往会遭遇到性能问题。当用户每次调用select()或poll()时，内核会对传入的所有文件描述符都检查一遍，并记录其中有哪些文件描述符存在I&#x2F;O就绪，这个操作的耗时将随着文件描述符数量的增加而线性增长。</p>
<p>另一个重要因素也会影响select()和poll()的性能，例如用户每次调用poll()时，都需要传递一个pollfd数组，而poll()会将这个数组从用户空间拷贝到内核空间，当内核对这个数组作了修改之后，poll()又会将这个数组从内核空间拷贝到用户空间。随着pollfd数组长度的增加，每次拷贝的时间也会线性增长，一旦poll()需要监听大量的文件描述符，每次调用poll()时，这个拷贝操作将带来不小的开销。这个问题的根源在于select()和poll()的API设计不当，例如，对于应用程序来说，它每次调用poll()所监听的文件描述符集合应该是差不多的，所以我们不禁这样想，如果内核愿意提供一个数据结构，记录程序所要监听的文件描述符集合，这样每次用户调用poll()时，poll()就不需要将pollfd数组拷贝来拷贝去了（没错，epoll 就是这样解决的）。</p>
<h3 id="三、epoll"><a href="#三、epoll" class="headerlink" title="三、epoll"></a>三、epoll</h3><blockquote>
<p>epoll是为了解决select()和poll()中存在的问题</p>
</blockquote>
<p>epoll是个模块，由三个系统调用（epoll_create epoll_ctl epoll_wait）组成，Epoll 系统调用可帮助我们在内核中创建和管理上下文。epoll使用红黑树（RB-tree）数据结构来跟踪当前正在监视的所有文件描述符。</p>
<p>我们将任务分为3个步骤：</p>
<ul>
<li>使用epoll_create在内核中创建上下文</li>
<li>使用epoll_ctl向&#x2F;从上下文中添加和删除文件描述符</li>
<li>使用epoll_wait等待上下文中的事件</li>
</ul>
<p>epoll_ctl()负责增加、删除或修改红黑树上的节点，而epoll_wait()则负责返回双向链表中就绪的文件描述符(及其事件)。</p>
<p>当网卡收到一个 packet 的时候，会触发一个硬件中断，这导致内核调用相应的中断 handler，从网卡中读入数据放到协议栈，当数据量满足一定条件时，内核将回调ep_poll_callback()这个方法，它负责把这个就绪的文件描述符添加到双向链表中。这样当用户调用epoll_wait()时，epoll_wait()所做的就只是检查双向链表是否为空，如果不为空，就把文件描述符和数量返回给用户即可。</p>
<h4 id="触发模式"><a href="#触发模式" class="headerlink" title="触发模式"></a>触发模式</h4><p>epoll提供边沿触发（Edge-Triggered）及状态触发（Level-Triggered）模式。</p>
<blockquote>
<p>Level-Triggered 也翻译成水平触发、条件触发</p>
</blockquote>
<p><strong>边沿触发：</strong><br>监控对象的状态发生改变时触发，此后如果状态一直没有发生变化应用程序将不再收到通知</p>
<p><strong>状态触发：</strong><br>处于某种状态下（如缓冲区可以读）就一直触发</p>
<p><strong>如：</strong><br>socket接收到缓存数据时，调用epoll_wait，上面两种方法都将返回，表明存在要读取的数据。<br>假设读取器仅消耗了缓冲区中的部分数据。<br>在状态触发模式下，epoll_wait只要管道的缓冲区包含要读取的数据，对epoll_wait的调用将立即返回；<br>但是，在边沿触发模式下，epoll_wait仅在将新数据写入缓存区后才返回。</p>
<h4 id="一般编程逻辑"><a href="#一般编程逻辑" class="headerlink" title="一般编程逻辑"></a>一般编程逻辑</h4><ol>
<li><p>【epoll_create】在内核中创建epoll实例并返回一个epoll文件描述符（epfd）。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create1(int flags);</span><br></pre></td></tr></table></figure>
</li>
<li><p>【epoll_ctl】向epfd对应的内核epoll实例添加、修改或删除对fd（File descriptor）上事件event的监听。类型可以为EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL分别对应的是添加新的事件，修改文件描述符上监听的事件类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>
</li>
<li><p>【epoll_wait】循环执行epoll_wait，当timeout 为0 时，epoll_wait 永远会立即返回。而timeout 为-1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当timeout 为一正整数时，epoll 会阻塞直到计时timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过timeout 毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>我们可以在等待时添加和删除文件描述符</li>
<li>epoll_wait仅返回具有就绪文件描述符的对象</li>
<li>epoll具有更好的性能-（Epoll时间复杂度为O(1) 代替之前的O(n)）</li>
<li>epoll可以表现为状态触发或边缘触发</li>
</ul>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>epoll是特定于Linux的，因此不可移植</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/%E8%B7%AF%E7%94%B1%E5%99%A8&%E5%85%89%E7%8C%AB/%E9%85%8D%E7%BD%AEIPTV%E7%94%A8wifi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/%E8%B7%AF%E7%94%B1%E5%99%A8&%E5%85%89%E7%8C%AB/%E9%85%8D%E7%BD%AEIPTV%E7%94%A8wifi/" class="post-title-link" itemprop="url">配置IPTV用wifi</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-11 23:41:00" itemprop="dateCreated datePublished" datetime="2020-08-11T23:41:00+08:00">2020-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">硬件与物联网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB/" itemprop="url" rel="index"><span itemprop="name">路由器&光猫</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>346</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用原因：弱电箱在门口，光猫在弱电箱里面，从弱电箱到电视机只有一根网线，路由器放到电视柜上面，这根网线给了路由器用了，IPTV没有线。</p>
<p>其他方案：</p>
<ol>
<li>8芯网线分成两根4芯的网线（速度只有100M）</li>
<li>电力猫（干扰大）</li>
<li>使用网管交换机，用vlan （要另外买设备）</li>
<li>路由器和光猫上分别配置Vlan</li>
</ol>
<h3 id="用超级账号登陆光猫"><a href="#用超级账号登陆光猫" class="headerlink" title="用超级账号登陆光猫"></a>用超级账号登陆光猫</h3><blockquote>
<p>如何获取超级账号密码需要另外想办法<br>有限地方的超级账号密码都是同一个，网上能查得到</p>
</blockquote>
<h3 id="去掉宽带的无线绑定"><a href="#去掉宽带的无线绑定" class="headerlink" title="去掉宽带的无线绑定"></a>去掉宽带的无线绑定</h3><p><strong>网络 -&gt;  宽带设置</strong>  </p>
<p>连接名称 选择 2_INTERNET_R_VID_<br>将下面  绑定端口： 无线(2.4G-x) 的勾 去掉，点击应用</p>
<p><img src="https://img.wangwen135.top:23456/image/2024/07/66a90fb54a422.png" alt="修改端口绑定.png"></p>
<h3 id="设置iptv的无线绑定"><a href="#设置iptv的无线绑定" class="headerlink" title="设置iptv的无线绑定"></a>设置iptv的无线绑定</h3><p><strong>网络 -&gt;  宽带设置</strong></p>
<p>选择 3_Other_B_VID_45<br>这个就是IPTV，将无线勾上，点击应用</p>
<p><img src="https://img.wangwen135.top:23456/image/2024/07/66a90feca15b6.png" alt="IPTV无线绑定.png"></p>
<h3 id="修改WLAN配置启动无线"><a href="#修改WLAN配置启动无线" class="headerlink" title="修改WLAN配置启动无线"></a>修改WLAN配置启动无线</h3><p>**网络 -&gt; WLAN配置 **  </p>
<p>SSID 使能的勾勾上<br><img src="https://img.wangwen135.top:23456/image/2024/07/66a910153323a.png" alt="SSID使能.png"></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h3 id="机顶盒设置wifi连接"><a href="#机顶盒设置wifi连接" class="headerlink" title="机顶盒设置wifi连接"></a>机顶盒设置wifi连接</h3><p>打开电视 和 机顶盒，按遥控的设置，进入维护登陆界面<br>机顶盒维护初始密码： 6321</p>
<p>进入网络选择无线，填入密码就行了（不行就试试将连接方式换成PPPOE试试，忘了）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/Netty/Netty%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Netty/Netty%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Netty 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-23 23:41:00" itemprop="dateCreated datePublished" datetime="2020-06-23T23:41:00+08:00">2020-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>基于netty 4.x</strong></p>
<p><strong>相关页面地址</strong>：<br>4.x用户指南：<a target="_blank" rel="noopener" href="https://netty.io/wiki/user-guide-for-4.x.html">https://netty.io/wiki/user-guide-for-4.x.html</a><br>Netty Example：<a target="_blank" rel="noopener" href="https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example">https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example</a><br>API：<a target="_blank" rel="noopener" href="https://netty.io/4.1/xref/index.html">https://netty.io/4.1/xref/index.html</a></p>
<h2 id="Netty框架"><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h2><p>Netty是一个基于NIO的异步事件驱动的网络应用程序框架和工具，使用他可以快速轻松的开发<br>出高性能和高扩展性的网络应用程序，例如自定义协议的服务器和客户端。它极大地简化和简化了网络编程，如TCP和UDP套接字服务器的开发。</p>
<h2 id="线程模型与异步处理"><a href="#线程模型与异步处理" class="headerlink" title="线程模型与异步处理"></a>线程模型与异步处理</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>Reactor（反应堆模型）<br>Reactor模式也叫Dispatcher模式，即I&#x2F;O多路复用统一监听事件，收到事件后分发(Dispatch给某进程)</p>
<blockquote>
<p>Reactor就是一个执行while (true) { selector.select(); …}循环的线程，会源源不断的产生新的事件</p>
</blockquote>
<p><img src="https://img.wangwen135.top:23456/note/2024/06/666a669125aff.png" alt="1718249102415.png"></p>
<p>Reactor模型中有2个关键组成：</p>
<ul>
<li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。</li>
<li>Handlers 处理程序执行I&#x2F;O事件要完成的实际事件</li>
</ul>
<p>取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种</p>
<ul>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ul>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>Netty主要基于主从Reactors多线程模型，其中Reactor分为：MainReactor和SubReactor：</p>
<ul>
<li>MainReactor负责客户端的连接请求，并将请求转交给SubReactor</li>
<li>SubReactor负责相应通道的IO读写请求</li>
<li>非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理</li>
</ul>
<p>虽然Netty的线程模型基于主从Reactor多线程，但是实际实现上SubReactor和Worker线程在同一个线程池中</p>
<ul>
<li>bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，每个端口对应一个boss线程</li>
<li>workerGroup线程池会被各个SubReactor和worker线程充分利用</li>
</ul>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>Netty中的I&#x2F;O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>
<ul>
<li>通过isDone方法来判断当前操作是否完成</li>
<li>通过isSuccess方法来判断已完成的当前操作是否成功</li>
<li>通过getCause方法来获取已完成的当前操作失败的原因</li>
<li>通过isCancelled方法来判断已完成的当前操作是否被取消</li>
<li>通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则立即通知指定的监听器</li>
</ul>
<hr>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>Netty中使用了自己实现的ByteBuffer，直接内存，内存池化，引用计数器等技术，重点要看一下 io.netty.buffer.ByteBuf</p>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><p>零个或多个字节（八位字节）的随机且顺序可访问的序列。此接口提供一个或多个原始字节数组（byte []）和NIO buffers 的抽象视图。</p>
<h4 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h4><p>建议在Unpooled中使用辅助方法创建一个新的缓冲区，而不是调用单个实现的构造函数。</p>
<h4 id="随机存取索引"><a href="#随机存取索引" class="headerlink" title="随机存取索引"></a>随机存取索引</h4><p>就像普通的原始字节数组一样，ByteBuf使用从零开始的索引。这意味着第一个字节的索引始终为0，而最后一个字节的索引始终为-1。例如，要迭代缓冲区的所有字节，您可以不管其内部实现如何，请执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ...;</span><br><span class="line">for (int i = 0; i &lt; buffer.capacity(); i ++) &#123;</span><br><span class="line">    byte b = buffer.getByte(i);</span><br><span class="line">    System.out.println((char) b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="顺序访问索引"><a href="#顺序访问索引" class="headerlink" title="顺序访问索引"></a>顺序访问索引</h4><p>ByteBuf提供了两个指针变量来支持顺序读取和写入操作；分别是针对读操作的readerIndex和针对写操作的writerIndex。    </p>
<blockquote>
<p>无需像使用JDK中的Buffer那样手动flip()</p>
</blockquote>
<p><strong>读操作：</strong>  </p>
<p>名称以read或skip开头的任何操作都将获取或跳过当前readerIndex处的数据，并将其增加读取字节数。如果读取操作的参数是ByteBuf，并且未指定目标索引，则指定缓冲区的writerIndex会一起增加。<br>如果没有足够的内容，则会引发IndexOutOfBoundsException。<br>新分配，包装或复制的缓冲区的readerIndex的默认值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 迭代缓冲区的可读字节</span><br><span class="line">ByteBuf buffer = ...;</span><br><span class="line">while (buffer.isReadable()) &#123;</span><br><span class="line">    System.out.println(buffer.readByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>写操作：</strong></p>
<p>名称以write开头的任何操作都将在当前writerIndex处写入数据，并将增加其writerIndex的计数。如果写操作的参数是ByteBuf，并且未指定源索引，则指定缓冲区的readerIndex会一起增加。<br>如果没有足够的可写字节，则引发IndexOutOfBoundsException。新分配的缓冲区的writerIndex的默认值为0。包装或复制的缓冲区的writerIndex的默认值为缓冲区的容量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 用随机整数填充缓冲区的可写字节</span><br><span class="line">ByteBuf buffer = ...;</span><br><span class="line">while (buffer.maxWritableBytes() &gt;= 4) &#123;</span><br><span class="line">    buffer.writeInt(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>丢弃已经读取的字节：</strong></p>
<p>通过调用discardReadBytes()来丢弃已经读取的字节，以回收使用的字节区域。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 调用 discardReadBytes() 之前 （已经读取了一定的字节）</span><br><span class="line"></span><br><span class="line">     +-------------------+------------------+------------------+</span><br><span class="line">     | discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">     +-------------------+------------------+------------------+</span><br><span class="line">     |                   |                  |                  |</span><br><span class="line">     0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 调用 discardReadBytes()之后 （相关指针前移，已经读取过的内容被丢弃）</span><br><span class="line"></span><br><span class="line">     +------------------+--------------------------------------+</span><br><span class="line">     |  readable bytes  |    writable bytes (got more space)   |</span><br><span class="line">     +------------------+--------------------------------------+</span><br><span class="line">     |                  |                                      |</span><br><span class="line">readerIndex (0) &lt;= writerIndex (decreased)        &lt;=        capacity</span><br></pre></td></tr></table></figure>



<p><strong>清除缓冲区索引：</strong></p>
<p>可以通过调用clear()将readerIndex和writerIndex都设置为0，它不会清除缓冲区内容（例如填充0），而只是清除两个指针。</p>
<blockquote>
<p><strong>请注意，此操作的语义与java.nio.ByteBuffer.clear()不同。</strong></p>
</blockquote>
<h4 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h4><p>对于简单的单字节搜索，请使用indexOf(int，int，byte) 和 bytesBefore(int，int，byte) 。当处理以NUL结尾的字符串时，bytesBefore(byte) 特别有用。对于复杂的搜索，请使用带有ByteProcessorimplementation的forEachByte(int，int，ByteProcessor)。</p>
<h4 id="标记和重置"><a href="#标记和重置" class="headerlink" title="标记和重置"></a>标记和重置</h4><p>每个缓冲区中都有两个标记索引。一种用于存储readerIndex，另一种用于存储writerIndex。您始终可以通过调用reset方法来重新定位两个索引之一。除了没有readlimit以外，它的工作方式与InputStream中的mark和reset方法类似。</p>
<h4 id="派生缓冲区"><a href="#派生缓冲区" class="headerlink" title="派生缓冲区"></a>派生缓冲区</h4><p>您可以通过调用以下方法之一来创建现有缓冲区的视图：</p>
<ul>
<li>duplicate()</li>
<li>slice()</li>
<li>slice(int, int)</li>
<li>readSlice(int)</li>
<li>retainedDuplicate()</li>
<li>retainedSlice()</li>
<li>retainedSlice(int, int)</li>
<li>readRetainedSlice(int)</li>
</ul>
<p>派生的缓冲区将具有独立的readerIndex，writerIndex和标记索引，而它共享其他内部数据表示形式，就像NIO缓冲区一样。<br>如果需要现有缓冲区的全新副本，请调用 copy( ) 方法。</p>
<h4 id="非保留和保留派生缓冲区"><a href="#非保留和保留派生缓冲区" class="headerlink" title="非保留和保留派生缓冲区"></a>非保留和保留派生缓冲区</h4><p>请注意，plicate()，slice()，slice(int，int)和readSlice(int) 不会在返回的派生缓冲区上调用retain()，因此不会增加其引用计数。如果需要创建具有增加的引用计数的派生缓冲区，请考虑使用retainedDuplicate()，retainedSlice()，retainedSlice(int，int) 和 readRetainedSlice(int)，这可能会返回产生较少垃圾的缓冲区实现。</p>
<h4 id="转换为现有的JDK类型"><a href="#转换为现有的JDK类型" class="headerlink" title="转换为现有的JDK类型"></a>转换为现有的JDK类型</h4><p><strong>字节数组</strong></p>
<p>如果ByteBuf由字节数组（即byte []）支持，则可以直接通过array()方法访问它。要确定缓冲区是否由字节数组支持，应使用hasArray()。</p>
<p><strong>NIO缓冲区</strong></p>
<p>如果ByteBuf可以转换为共享其内容的NIO ByteBuffer（即视图缓冲区），则可以通过nioBuffer()方法获取它。要确定是否可以将缓冲区转换为NIO缓冲区，请使用nioBufferCount()。</p>
<p><strong>String</strong></p>
<p>各种toString(Charset)方法将ByteBufin转换为String。请注意，toString()不是转换方法。</p>
<p><strong>I&#x2F;O流</strong></p>
<p>请参考ByteBufInputStream和ByteBufOutputStream。</p>
<hr>
<h3 id="计数引用"><a href="#计数引用" class="headerlink" title="计数引用"></a>计数引用</h3><p>ByteBuf 实现了 ReferenceCounted 接口</p>
<p>在Netty handler的设计规范中，所有输入的数据在处理结束时都会调用ReferenceCountUtil.release()释放，只是具体释放方法根据池化、非池化、直接内存、堆内存的不同实现不同。</p>
<h4 id="ReferenceCounted"><a href="#ReferenceCounted" class="headerlink" title="ReferenceCounted"></a>ReferenceCounted</h4><p>一个引用计数的对象，需要显式取消分配。</p>
<p>实例化一个新的ReferenceCounted时，它以引用计数为1开头。keep() 增加引用计数，release() 减少引用计数。<br>如果引用计数减小为0，则将显式释放该对象，并且 访问已释放对象通常会导致访问冲突。</p>
<p>如果实现ReferenceCounted的对象是其他实现ReferenceCounted的对象的容器，则当容器的引用计数变为0时，包含的对象也将通过release() 释放。</p>
<h4 id="ReferenceCountUtil"><a href="#ReferenceCountUtil" class="headerlink" title="ReferenceCountUtil"></a>ReferenceCountUtil</h4><p>一个工具方法集合，处理的对象需要实现 ReferenceCounted</p>
<h3 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h3><p>实现零拷贝，既使用时无需将内存从系统空间复制到用户空间</p>
<p>主要是指接收和发送 ByteBuffer 使用虚拟机的堆外内存，不用将内存内容拷贝到jvm的堆中</p>
<h3 id="内存块池化"><a href="#内存块池化" class="headerlink" title="内存块池化"></a>内存块池化</h3><p>对于堆外内存的申请分配以及释放是一个比较耗时的操作，不能像jvm中一样快（jvm已经提前像系统申请了一块内存空间）<br>Netty为了重用这些内存，将内存分成一块一块的小内存，然后将内存块像线程池中的线程一样重复使用，来避免重复的分配和回收操作。（据说性能超高，没有测试过）  </p>
<h3 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h3><p>实现负责分配缓冲区。这个接口的实现应该是线程安全的。</p>
<h4 id="UnpooledByteBufAllocator"><a href="#UnpooledByteBufAllocator" class="headerlink" title="UnpooledByteBufAllocator"></a>UnpooledByteBufAllocator</h4><p>非池化内存分配器</p>
<h4 id="PooledByteBufAllocator"><a href="#PooledByteBufAllocator" class="headerlink" title="PooledByteBufAllocator"></a>PooledByteBufAllocator</h4><p>池化内存分配器</p>
<h3 id="io-netty-buffer-Unpooled"><a href="#io-netty-buffer-Unpooled" class="headerlink" title="io.netty.buffer.Unpooled"></a>io.netty.buffer.Unpooled</h3><p>通过分配新空间或包装或复制现有字节数组、字节缓冲区和字符串来创建新的ByteBuf。</p>
<p><strong>静态方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import static io.netty.buffer.Unpooled.*;</span><br><span class="line"></span><br><span class="line">ByteBuf heapBuffer    = buffer(128);</span><br><span class="line">ByteBuf directBuffer  = directBuffer(256);</span><br><span class="line">ByteBuf wrappedBuffer = wrappedBuffer(new byte[128], new byte[256]);</span><br><span class="line">ByteBuf copiedBuffer  = copiedBuffer(ByteBuffer.allocate(128));</span><br></pre></td></tr></table></figure>

<p><strong>分配新缓冲区</strong><br>buffer(int) 分配一个新的固定容量堆缓冲区。<br>directBuffer(int) 分配一个新的固定容量直接缓冲区。</p>
<p><strong>创建包装的缓冲区</strong><br>包装缓冲区是一种缓冲区，它是一个或多个现有字节数组和字节缓冲区的视图。原始数组或缓冲区内容的任何更改都将在包装的缓冲区中可见。提供了各种包装方法，它们的名称全为wrappedBuffer()。如果要创建一个由多个数组组成的缓冲区以减少内存副本的数量，则可能需要仔细研究一下接受varargs的方法。</p>
<p><strong>创建复制的缓冲区</strong><br>复制缓冲区是一个或多个现有字节数组，字节缓冲区或字符串的深层副本。与包装的缓冲区不同，原始数据和复制的缓冲区之间没有共享数据。提供了各种复制方法，它们的名称全为copyedBuffer()。使用此操作将多个缓冲区合并为一个缓冲区也很方便。</p>
<hr>
<h2 id="重点类介绍"><a href="#重点类介绍" class="headerlink" title="重点类介绍"></a>重点类介绍</h2><h3 id="启动辅助类"><a href="#启动辅助类" class="headerlink" title="启动辅助类"></a>启动辅助类</h3><h4 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h4><p><strong>服务端用</strong> </p>
<p>ServerBootstrapAcceptor的channelRead方法，<br>会将进入的连接注册到workerGroup （NioEventLoopGroup）中，之后的读写以及业务操作就是NioEventLoopGroup中的EventLoop来处理了</p>
<p>注册时会有一定的机制（DefaultEventExecutorChooserFactory，就是轮询）来决定用哪一个EventLoop来处理本次连接</p>
<h4 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h4><p><strong>客户端用</strong> </p>
<p>bind()方法与无连接传输如数据报（UDP）结合使用非常有用。对于常规TCP连接，请使用提供的connect()方法。</p>
<h3 id="Channel-（通道）"><a href="#Channel-（通道）" class="headerlink" title="Channel （通道）"></a>Channel （通道）</h3><p>网络套接字或能够进行I&#x2F;O操作(如读、写、连接和绑定)的组件的连接。</p>
<p><strong>通道为用户提供:</strong>  </p>
<ul>
<li>通道的当前状态(例如：是否打开，是否是连接状态)</li>
<li>通道的配置参数(例如接收缓冲区大小)</li>
<li>通道支持的I&#x2F;O操作(例如，读、写、连接和绑定)</li>
<li>ChannelPipeline处理与通道相关的所有I&#x2F;O事件和请求。</li>
</ul>
<p><strong>所有I&#x2F;O操作都是异步的</strong><br>Netty中的所有I&#x2F;O操作都是异步的。这意味着任何I&#x2F;O调用将立即返回，而不能保证所请求的I&#x2F;O操作在调用结束时已经完成。返回一个ChannelFuture实例，该实例将在请求的I&#x2F;O操作成功、失败或取消时通知你。</p>
<p><strong>释放资源</strong><br>一旦Channel使用完毕，调用ChannelOutboundInvoker.close()或ChannelOutboundInvoker.close(ChannelPromise)释放所有资源非常重要。这样可确保以适当的方式释放所有资源，如文件描述符。</p>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>TCP&#x2F;IP套接字通道</p>
<p>两个常用子类<br><strong>NioServerSocketChannel</strong>  用于服务端，它使用基于NIO选择器的实现来接受新连接。<br><strong>NioSocketChannel</strong> 用于客户端，它使用基于NIO选择器的实现  </p>
<h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><p>UDP&#x2F;IP 通道</p>
<p>常用子类<br><strong>NioDatagramChannel</strong> NIO的UDP数据包通道</p>
<h3 id="NioEventLoop-（事件循环）"><a href="#NioEventLoop-（事件循环）" class="headerlink" title="NioEventLoop （事件循环）"></a>NioEventLoop （事件循环）</h3><p>SingleThreadEventLoop的实现，它将Channel注册到选择器中，并且在事件循环中对它们进行多路复用。<br>该类在单个线程中以有序&#x2F;串行的方式执行提交的所有任务。</p>
<p>本质上是一个单线程的线程池，通过execute方法提交的任务都将被这个Thread线程来执行</p>
<p>在注册时会执行execute方法，调用doStartThread，启动事件循环</p>
<blockquote>
<p> 调用doStartThread 只会执行一次</p>
</blockquote>
<p>代码在：</p>
<blockquote>
<p>SingleThreadEventExecutor.doStartThread()<br>SingleThreadEventExecutor.this.run();</p>
</blockquote>
<p>里面有个固定无限循环，来判断selector中是否有事件</p>
<p>就像我们写NOI的那个循环一样  </p>
<blockquote>
<p>NioEventLoop.run()</p>
</blockquote>
<blockquote>
<p>还实现了：ScheduledExecutorService 调度线程池</p>
</blockquote>
<p>channel 会绑定到一个eventLoop中，这个channel对应的所有操作都会由这个eventLoop来执行,<br>包括所有的IO操作和handler中业务逻辑</p>
<p>但是多个channel 可能会被分配到同一个eventLoop中</p>
<p>因为是单线程的，它将以有序&#x2F;串行方式处理所有提交的任务，这样不必要考虑并发同步的问题。</p>
<h3 id="NioEventLoopGroup-（事件循环组）"><a href="#NioEventLoopGroup-（事件循环组）" class="headerlink" title="NioEventLoopGroup （事件循环组）"></a>NioEventLoopGroup （事件循环组）</h3><p>MultithreadEventLoopGroup的实现，用于基于NIO 选择器的Channel。<br>它同时使用多个线程处理它的任务，通过它的next()方法提供要使用的EventExecutor。除此之外，它还负责处理它们的生命周期，并允许以全局方式关闭它们。</p>
<blockquote>
<p>new NioEventLoopGroup() 没有参数时:</p>
<ul>
<li>默认的NioEventLoop的数量是机器CPU数量的两倍</li>
<li>默认的拒绝策略是：拒绝（抛异常）</li>
<li>eventLoop做事件循环时的Selector如果没有指定将使用系统默认的，如windows的WindowsSelectorProvider</li>
</ul>
</blockquote>
<p>NioEventLoopGroup是用来管理NioEventLoop的，里面有一个 <code>EventExecutor[] children; </code>管理着这个组下的全部事件循环EventLoop对象</p>
<p>初始化时会实例化全部的NioEventLoop对象，通过 <code>EventLoop newChild(Executor executor, Object... args)</code> 方法</p>
<p>channel初始化时会进行注册，注册通道时调用 <code>next().register(channel)</code></p>
<p>服务端程序在 ServerBootstrapAcceptor 的channelRead 方法中将新的channel注册到workerGroup中</p>
<p>next方法会通过EventExecutorChooser（默认轮询）来获取EventExecutor（NioEventLoop）</p>
<blockquote>
<p><strong>bossGroup</strong> 只需要一个 NioEventLoop 就可以了，只负责将channel注册到 workerGroup 中<br><strong>workerGroup</strong> 默认CPU核心数*2 个NioEventLoop</p>
</blockquote>
<h3 id="ChannelPipeline-（管道）"><a href="#ChannelPipeline-（管道）" class="headerlink" title="ChannelPipeline （管道）"></a>ChannelPipeline （管道）</h3><p>ChannelHandler的列表，用于处理或拦截Channel的入站事件和出站操作。<br>ChannelPipeline实现了一种高级的拦截、过滤模式，以使用户可以完全控制事件的处理方式以及管道中的ChannelHandler如何相互交互。</p>
<p>每个Channel都有其自己的ChannelPipeline，并且在创建新Channel时会自动创建它。</p>
<p>下图描述了ChannelPipeline典型地ChannelHandler如何处理I&#x2F;O事件。 I&#x2F;O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead(Object)和ChannelHandlerContext.write(Object)）转发到其最近的处理程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                                               I/O Request</span><br><span class="line">                                          via &#123;@link Channel&#125; or</span><br><span class="line">                                      &#123;@link ChannelHandlerContext&#125;</span><br><span class="line">                                                    |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|/              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">                |                                  \|/</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>


<p>入站事件由入站处理程序在自下而上的方向上进行处理，如该图的左侧所示。入站处理程序通常处理由图底部的I&#x2F;O线程生成的入站数据。通常通过实际的输入操作（例如SocketChannel.read（ByteBuffer））从远程对等方读取入站数据。如果入站事件超出了顶部入站处理程序的范围，则将其静默丢弃，或者在需要引起注意时将其记录下来。</p>
<p>出站事件由出站处理程序按自上而下的方向进行处理，如该图的右侧所示。出站处理程序通常会生成或转换出站流量（例如写请求）。如果出站事件超出了底部出站处理程序，则由与通道关联的I&#x2F;O线程处理。 I&#x2F;O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p>
<p>假设我们创建了如下的管道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline p = ...;</span><br><span class="line">p.addLast(&quot;1&quot;, new InboundHandlerA());</span><br><span class="line">p.addLast(&quot;2&quot;, new InboundHandlerB());</span><br><span class="line">p.addLast(&quot;3&quot;, new OutboundHandlerA());</span><br><span class="line">p.addLast(&quot;4&quot;, new OutboundHandlerB());</span><br><span class="line">p.addLast(&quot;5&quot;, new InboundOutboundHandlerX());</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，名称以Inbound开头的类表示它是一个入站处理程序。名称以Outbound开头的类表示它是一个出站处理程序。<br>在给定的示例配置中，事件进入时处理程序的评估顺序为1、2、3、4、5。事件离开时，处理程序的评估顺序为5、4、3、2、1。   </p>
<p>ChannelPipeline跳过某些处理程序的评估，以缩短堆栈深度：</p>
<ul>
<li>3和4没有实现ChannelInboundHandler，因此入站事件的实际评估顺序为：1、2和5。</li>
<li>1和2没有实现ChannelOutboundHandler，因此出站事件的实际评估顺序为：5、4和3。</li>
<li>如5同时实现ChannelInboundHandler和ChannelOutboundHandler，则入站和出站事件的评估顺序可能分别为1 2 5和5 4 3。</li>
</ul>
<p>ChannelPipeline是线程安全的，也就是说，我们可以动态的添加、删除其中的ChannelHandler。考虑这样的场景：服务器需要对用户登录信息进行加密，而其他信息不加密，则可以首先将加密Handler添加到ChannelPipeline，验证完用户信息后，主动从ChnanelPipeline中删除，从而实现该需求</p>
<h3 id="ChannelHandlerContext-（处理器的上下文）"><a href="#ChannelHandlerContext-（处理器的上下文）" class="headerlink" title="ChannelHandlerContext （处理器的上下文）"></a>ChannelHandlerContext （处理器的上下文）</h3><p>channelHandler 的上下文对象，使ChannelHandler可以与ChannelPipeline中的其他Handler进行交互。<br>使用上下文对象，ChannelHandler可以在上下游传递事件，动态修改管道（在管道中动态的插入或删除ChannelHandler）或存储特定于处理程序的信息（使用AttributeKeys）。</p>
<p><strong>结合ChannelPipeline</strong><br>处理程序必须调用ChannelHandlerContext中的事件传播方法，以将事件转发到其下一个处理程序。这些方法包括：</p>
<p>入站事件传播方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerContext.fireChannelRegistered()</span><br><span class="line">ChannelHandlerContext.fireChannelActive()</span><br><span class="line">ChannelHandlerContext.fireChannelRead(Object)</span><br><span class="line">ChannelHandlerContext.fireChannelReadComplete()</span><br><span class="line">ChannelHandlerContext.fireExceptionCaught(Throwable)</span><br><span class="line">ChannelHandlerContext.fireUserEventTriggered(Object)</span><br><span class="line">ChannelHandlerContext.fireChannelWritabilityChanged()</span><br><span class="line">ChannelHandlerContext.fireChannelInactive()</span><br><span class="line">ChannelHandlerContext.fireChannelUnregistered()</span><br></pre></td></tr></table></figure>
<p>出站事件传播方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerContext.bind(SocketAddress，ChannelPromise)</span><br><span class="line">ChannelHandlerContext.connect(SocketAddress，SocketAddress，ChannelPromise)</span><br><span class="line">ChannelHandlerContext.write(Object，ChannelPromise)</span><br><span class="line">ChannelHandlerContext.flush()</span><br><span class="line">ChannelHandlerContext.read()</span><br><span class="line">ChannelHandlerContext.disconnect(ChannelPromise)</span><br><span class="line">ChannelHandlerContext.close(ChannelPromise)</span><br><span class="line">ChannelHandlerContext.deregister(ChannelPromise)</span><br></pre></td></tr></table></figure>

<p>如何进行事件传播:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyInboundHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">         System.out.println(&quot;Connected!&quot;);</span><br><span class="line">         ctx.fireChannelActive();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public class MyOutboundHandler extends ChannelOutboundHandlerAdapter &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void close(ChannelHandlerContext ctx, ChannelPromise promise) &#123;</span><br><span class="line">         System.out.println(&quot;Closing ..&quot;);</span><br><span class="line">         ctx.close(promise);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ChannelInitializer（通道初始化器）"><a href="#ChannelInitializer（通道初始化器）" class="headerlink" title="ChannelInitializer（通道初始化器）"></a>ChannelInitializer（通道初始化器）</h3><p>一个特殊的ChannelHandler，用于给ChannelPipeline绑定handler<br>在连接建立时会调用handlerAdded方法然后调用initChannel方法，然后执行我们编写的<br>channelPipeline.addLast(new StringDecoder())<br>等代码，这里使用的是new 一个新对象，这样就能给每一个连接创建独立的handler实例了，这些实例就可以保存各种状态</p>
<hr>
<h3 id="ChannelHandler（处理器）"><a href="#ChannelHandler（处理器）" class="headerlink" title="ChannelHandler（处理器）"></a>ChannelHandler（处理器）</h3><p>处理网络IO事件，对消息进行编码解码，和一定的业务逻辑处理。我们主要就实现各种Handler。  </p>
<blockquote>
<p>过长时间的业务逻辑代码如果编写在ChannelHandler中，不能直接在workerGroup线程池中处理，可能阻塞其他的IO操作<br>通过外部线程池，或指定Handler的执行线程池来处理</p>
</blockquote>
<p>通常必须实现下面的两个子类之一：</p>
<ol>
<li>ChannelInboundHandler 处理入站I&#x2F;O事件</li>
<li>ChannelOutboundHandler 处理出站I&#x2F;O事件</li>
</ol>
<p>另外还提供了以下适配器类：  </p>
<ul>
<li>ChannelInboundHandlerAdapter 处理入站I&#x2F;O事件</li>
<li>ChannelOutboundHandlerAdapter 处理出站I&#x2F;事件</li>
<li>ChannelDuplexHandler 可以处理入站和出站事件</li>
</ul>
<h4 id="Handler中的状态管理"><a href="#Handler中的状态管理" class="headerlink" title="Handler中的状态管理"></a>Handler中的状态管理</h4><h5 id="1-在Handler实现类中使用成员变量控制状态"><a href="#1-在Handler实现类中使用成员变量控制状态" class="headerlink" title="1. 在Handler实现类中使用成员变量控制状态"></a>1. 在Handler实现类中使用成员变量控制状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DataServerHandler extends SimpleChannelInboundHandler&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">     private boolean loggedIn;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void channelRead0(ChannelHandlerContext ctx, Message message) &#123;</span><br><span class="line">         if (message instanceof LoginMessage) &#123;</span><br><span class="line">             authenticate((LoginMessage) message);</span><br><span class="line">             loggedIn = true;</span><br><span class="line">         &#125; else (message instanceof GetDataMessage) &#123;</span><br><span class="line">             if (loggedIn) &#123;</span><br><span class="line">                 ctx.writeAndFlush(fetchSecret((GetDataMessage) message));</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 fail();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为处理程序实例具有专用于一个连接的状态变量，所以您必须为每个新通道创建一个新的处理程序实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DataServerInitializer extends ChannelInitializer&lt;Channel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initChannel(Channel channel) &#123;</span><br><span class="line">        channel.pipeline().addLast(&quot;handler&quot;, new DataServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-使用ChannelHandlerContext提供的AttributeKey"><a href="#2-使用ChannelHandlerContext提供的AttributeKey" class="headerlink" title="2. 使用ChannelHandlerContext提供的AttributeKey"></a>2. 使用ChannelHandlerContext提供的AttributeKey</h5><p>当不想创建许多处理器的实例时，用可以使用ChannelHandlerContext提供的AttributeKey来存储程序的状态信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Sharable</span><br><span class="line"> public class DataServerHandler extends SimpleChannelInboundHandler&lt;Message&gt; &#123;</span><br><span class="line">     private final AttributeKey&lt;Boolean&gt; auth =</span><br><span class="line">           AttributeKey.valueOf(&quot;auth&quot;);</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void channelRead(ChannelHandlerContext ctx, Message message) &#123;</span><br><span class="line">         Attribute&lt;Boolean&gt; attr = ctx.attr(auth);</span><br><span class="line">         if (message instanceof LoginMessage) &#123;</span><br><span class="line">             authenticate((LoginMessage) o);</span><br><span class="line">             attr.set(true);</span><br><span class="line">         &#125; else (message instanceof GetDataMessage) &#123;</span><br><span class="line">             if (Boolean.TRUE.equals(attr.get())) &#123;</span><br><span class="line">                 ctx.writeAndFlush(fetchSecret((GetDataMessage) o));</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 fail();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>只需要一个处理器的实例即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DataServerInitializer extends ChannelInitializer&lt;Channel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final DataServerHandler SHARED = new DataServerHandler();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initChannel(Channel channel) &#123;</span><br><span class="line">        channel.pipeline().addLast(&quot;handler&quot;, SHARED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要注意这些ChannelHandler的线程安全性</p>
<h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p><strong>提供此注释是为了文档目的，就像JCIP注释一样。实际上是否创建多个实例取决于上面的两种写法</strong></p>
<p>如果ChannelHandler使用@Sharable注解进行标注，则表示可以只创建一次该处理程器的实例，然后将其多次添加到一个或多个ChannelPipelines中</p>
<p>如果未指定此注释，则每次将其添加到管道时都必须创建一个新的处理程序实例，因为它具有未共享的状态，例如成员变量。</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h3><p>ChannelOption允许以类型安全的方式配置ChannelConfig。 支持哪个ChannelOption取决于ChannelConfig的实际实现，并且可能取决于其所属传输的性质。</p>
<h3 id="ChannelConfig"><a href="#ChannelConfig" class="headerlink" title="ChannelConfig"></a>ChannelConfig</h3><p>通道的一组配置属性</p>
<p>请向下转换为更特定的配置类型，例如SocketChannelConfig或使用setOptions（Map）设置特定于传输的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel ch = ...;</span><br><span class="line">SocketChannelConfig cfg = (SocketChannelConfig) ch.getConfig();</span><br><span class="line">cfg.setTcpNoDelay(false);</span><br></pre></td></tr></table></figure>



<p><strong>Option map</strong></p>
<p>选项map 属性是动态只写属性，它允许配置Channel而不向下转换其关联的ChannelConfig。要更新选项map，请调用setOptions(Map)。<br>所有ChannelConfig都具有以下选项：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>关联的setter方法</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelOption.CONNECT_TIMEOUT_MILLIS</td>
<td>setConnectTimeoutMillis(int)</td>
</tr>
<tr>
<td>ChannelOption.WRITE_SPIN_COUNT</td>
<td>setWriteSpinCount(int)</td>
</tr>
<tr>
<td>ChannelOption.WRITE_BUFFER_WATER_MARK</td>
<td>setWriteBufferWaterMark(WriteBufferWaterMark)</td>
</tr>
<tr>
<td>ChannelOption.ALLOCATOR</td>
<td>setAllocator(ByteBufAllocator)</td>
</tr>
<tr>
<td>ChannelOption.AUTO_READ</td>
<td>setAutoRead(boolean)</td>
</tr>
</tbody></table>
<h4 id="SocketChannelConfig"><a href="#SocketChannelConfig" class="headerlink" title="SocketChannelConfig"></a>SocketChannelConfig</h4><p><strong>可用选项</strong></p>
<p>除了ChannelConfig提供的选项外，SocketChannelConfig允许在选项映射中使用以下选项:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>关联的setter方法</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelOption.SO_KEEPALIVE</td>
<td>setKeepAlive(boolean)</td>
</tr>
<tr>
<td>ChannelOption.SO_REUSEADDR</td>
<td>setReuseAddress(boolean)</td>
</tr>
<tr>
<td>ChannelOption.SO_LINGER</td>
<td>setSoLinger(int)</td>
</tr>
<tr>
<td>ChannelOption.TCP_NODELAY</td>
<td>setTcpNoDelay(boolean)</td>
</tr>
<tr>
<td>ChannelOption.SO_RCVBUF</td>
<td>setReceiveBufferSize(int)</td>
</tr>
<tr>
<td>ChannelOption.SO_SNDBUF</td>
<td>setSendBufferSize(int)</td>
</tr>
<tr>
<td>ChannelOption.IP_TOS</td>
<td>setTrafficClass(int)</td>
</tr>
<tr>
<td>ChannelOption.ALLOW_HALF_CLOSURE</td>
<td>setAllowHalfClosure(boolean)</td>
</tr>
</tbody></table>
<h3 id="主动释放对象"><a href="#主动释放对象" class="headerlink" title="主动释放对象"></a>主动释放对象</h3><p>这里主要指的是ByteBuf  </p>
<p>ByteBuf是一个引用计数对象（ReferenceCounted），必须通过该release()方法显式释放它。请记住，释放任何传递给处理程序的引用计数对象是处理程序的责任。通常，channelRead()处理程序方法的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Do something with msg</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><h4 id="从字节流到数据包（碎片化问题）"><a href="#从字节流到数据包（碎片化问题）" class="headerlink" title="从字节流到数据包（碎片化问题）"></a>从字节流到数据包（碎片化问题）</h4><p>在基于流的传输（例如TCP &#x2F; IP）中，将接收到的数据存储到套接字接收缓冲区中。基于流的传输的缓冲区不是数据包队列而是字节队列。这意味着，即使您将两个消息作为两个独立的数据包发送，操作系统也不会将它们视为两个消息，而只是一堆字节。因此，不能保证你读到的内容与远程对等方写的完全一样。</p>
<p>例如，让我们假设操作系统的TCP&#x2F;IP堆栈已收到三个数据包：  </p>
<blockquote>
<p>【ABC】【DEF】【GHI】  </p>
</blockquote>
<p>由于是基于流的传输协议，因此很有可能在你的应用程序中以以下分段形式读取它们：  </p>
<blockquote>
<p>【AB】【CDEFG】【H】【I】  </p>
</blockquote>
<p>因此，无论是服务器端还是客户端，接收方都应将接收到的数据整理到一个或多个有意义的帧中，以使应用程序逻辑易于理解。在上面的示例中，接收到的数据应采用以下格式：  </p>
<blockquote>
<p>【ABC】【DEF】【GHI】 </p>
</blockquote>
<h5 id="处理方案一"><a href="#处理方案一" class="headerlink" title="处理方案一"></a>处理方案一</h5><p>创建一个内部累积缓冲区，然后等待直到所有的字节都被接收到内部缓冲区中为止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package io.netty.example.time;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class TimeClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    private ByteBuf buf;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        buf = ctx.alloc().buffer(4); // (1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        buf.release(); // (1)</span><br><span class="line">        buf = null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg;</span><br><span class="line">        buf.writeBytes(m); // (2)</span><br><span class="line">        m.release();</span><br><span class="line">        </span><br><span class="line">        if (buf.readableBytes() &gt;= 4) &#123; // (3)</span><br><span class="line">            long currentTimeMillis = (buf.readUnsignedInt() - 2208988800L) * 1000L;</span><br><span class="line">            System.out.println(new Date(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>一个ChannelHandler有两个生命周期侦听器方法：handlerAdded()和handlerRemoved()。可以执行任意（取消）初始化任务，只要它不会长时间阻塞即可。</li>
<li>应将所有接收到的数据累加到中buf</li>
<li>然后，处理程序必须检查是否buf有足够的数据（在此示例中为4个字节），然后继续进行实际的业务逻辑。否则，Netty将channelRead()在有更多数据到达时再次调用该方法，最终将累加所有4个字节。</li>
</ol>
<h5 id="处理方案二"><a href="#处理方案二" class="headerlink" title="处理方案二"></a>处理方案二</h5><p>添加多个ChannelHandler到ChannelPipeline，拆分一个ChannelHandler成多个，使其模块化减少应用程序的复杂性。</p>
<p><strong>使用编码解码器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public class TimeDecoder extends ByteToMessageDecoder &#123; // (1)</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) &#123; // (2)</span><br><span class="line">        if (in.readableBytes() &lt; 4) &#123;</span><br><span class="line">            return; // (3)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        out.add(in.readBytes(4)); // (4)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>ByteToMessageDecoder是一个实现ChannelInboundHandler，可以轻松处理碎片问题。</li>
<li>ByteToMessageDecoderdecode()每当接收到新数据时，都使用内部维护的累积缓冲区调用该方法。</li>
<li>decode()可以决定out不向累积缓冲区中没有足够数据的位置添加任何内容。收到更多数据时ByteToMessageDecoder将decode()再次调用。</li>
<li>如果decode()将对象添加到out，则表示解码器成功解码了一条消息。ByteToMessageDecoder将丢弃累积缓冲区的读取部分。请记住，您不需要解码多条消息。ByteToMessageDecoder会一直调用该decode()方法，直到该方法不添加任何内容out。</li>
</ol>
<p><strong>累积缓冲区有两种实现</strong></p>
<ol>
<li>MERGE_CUMULATOR<br>通过使用内存副本，将它们合并到一个ByteBuf中来累积ByteBufs。</li>
<li>COMPOSITE_CUMULATOR<br>通过将bytebuf添加到CompositeByteBuf中来累积bytebuf，因此尽可能不进行内存复制。注意CompositeByteBuf使用了一个更复杂的索引实现，所以取决于你的用例和解码器实现，这可能比仅仅使用merge_accumulator要慢。</li>
</ol>
<p><strong>或者使用重复解码器 ReplayingDecoder</strong></p>
<p>ByteToMessageDecoder的变体，使得能够在阻塞I&#x2F;O范例中实现非阻塞解码器。<br>ReplayingDecoder您可以像已收到所有必需字节一样实现decode()和decodeLast()方法，而不用检查所需字节的可用性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TimeDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(</span><br><span class="line">            ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) &#123;</span><br><span class="line">        out.add(in.readBytes(4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReplayingDecoder通过一个特殊的ByteBuf 实现，Error当缓冲区中没有足够的数据时，该实现将抛出某种类型的实现。在上面的例子中只是假设调用时缓冲区中将有4个或更多字节。如果缓冲区中确实有4个字节，它将按预期返回整数标头。否则将引发Error。如果ReplayingDecoder捕获到 Error，则它将readerIndex把缓冲区的内容倒回到“初始”位置（即缓冲区的开头），并decode(..)在缓冲区中接收到更多数据时再次调用该方法。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/handler/codec/ReplayingDecoder.html">https://netty.io/4.1/api/io/netty/handler/codec/ReplayingDecoder.html</a></p>
<p>此外，Netty提供了开箱即用的解码器，使您能够非常轻松地实现大多数协议  </p>
<ul>
<li>io.netty.example.factorial  对于二进制协议</li>
<li>io.netty.example.telnet  用于基于文本行的协议</li>
</ul>
<h4 id="用POJO代替ByteBuf"><a href="#用POJO代替ByteBuf" class="headerlink" title="用POJO代替ByteBuf"></a>用POJO代替ByteBuf</h4><p>在handler中将字节流转成对象，然后在调用链中传递，会使我们开发程序变得更方便</p>
<p>经过解码器，将字节流转成对象之后再out出去，在调用链后面的Handler中就可以直接取到对象了</p>
<p>如：<br>解码器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) &#123;</span><br><span class="line">    if (in.readableBytes() &lt; 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.add(new UnixTime(in.readUnsignedInt()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    UnixTime m = (UnixTime) msg;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">    ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><p>通过ChannelHandlerContext的write方法异步发送应答消息个客户端<br>数据不直接写入SocketChannel，而是写入待发送数据的缓存区中 </p>
<p>ChannelHandlerContext的flush方法将队列中的消息写入到SockChannel中</p>
<h3 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><p>原理同线程池的关闭</p>
<p>channel.closeFuture().sync();</p>
<p>关闭所有事件循环以终止所有线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br></pre></td></tr></table></figure>

<h3 id="耗时任务处理"><a href="#耗时任务处理" class="headerlink" title="耗时任务处理"></a>耗时任务处理</h3><p>bossGroup用于来接受连接，workGroup用于处理业务逻辑和IO操作，如果在handler中执行的业务逻辑特别慢会阻塞IO操作</p>
<p>处理方法</p>
<h4 id="一、在hander中启动新的线程来执行耗时操作"><a href="#一、在hander中启动新的线程来执行耗时操作" class="headerlink" title="一、在hander中启动新的线程来执行耗时操作"></a>一、在hander中启动新的线程来执行耗时操作</h4><h4 id="二、告诉netty不要用之前定义的workGroup-来执行某些hander"><a href="#二、告诉netty不要用之前定义的workGroup-来执行某些hander" class="headerlink" title="二、告诉netty不要用之前定义的workGroup 来执行某些hander"></a>二、告诉netty不要用之前定义的workGroup 来执行某些hander</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 事件处理线程</span><br><span class="line">EventExecutorGroup eventExecutorGroup = new DefaultEventExecutorGroup(16);</span><br><span class="line"></span><br><span class="line">ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">    ChannelPipeline p = ch.pipeline();</span><br><span class="line">    p.addLast(new StringDecoder());</span><br><span class="line">    p.addLast(new StringEncoder());</span><br><span class="line">    </span><br><span class="line">    // 如果你的业务逻辑是完全异步的，或者完成得非常快，那么就不需要这样做</span><br><span class="line">    // 需要指定一个EventExecutorGroup，将用于执行ChannelHandler中的方法</span><br><span class="line">    p.addLast(eventExecutorGroup, &quot;String Echo&quot;, new StringEchoHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>…<br>…</p>
<hr>
<blockquote>
<p>大部分都是代码中的注释翻译过来的，没写完，有空再补充吧！</p>
</blockquote>
<h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//心跳检测，6分钟无心跳，触发关闭</span><br><span class="line">public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">    ......</span><br><span class="line">    pipeline.addLast( new IdleStateHandler( 6, 0, 0, TimeUnit.MINUTES ) );</span><br><span class="line">    ......</span><br><span class="line">&#125;       </span><br><span class="line">       </span><br><span class="line">//6分钟没有读取到消息，会触发：userEventTriggered 方法</span><br><span class="line"></span><br><span class="line">XxxxHandler</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">	if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">		IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">		if (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">			logger.warn(&quot;到达指定时间间隔没有收到心跳，关闭连接：&#123;&#125;&quot;, ctx.channel().remoteAddress());</span><br><span class="line">			ctx.fireUserEventTriggered(evt);</span><br><span class="line">			ctx.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		super.userEventTriggered(ctx, evt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C/ARP%20%E4%B8%8E%20RARP%20%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C/ARP%20%E4%B8%8E%20RARP%20%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">ARP 与 RARP 协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-03T00:00:00+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络与安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。<br>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<h2 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h2><p>反向地址转换协议（RARP）是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议，其功能与地址解析协议相反。与ARP相比，RARP的工作流程也相反。首先是查询主机向网路送出一个RARP Request广播封包，向别的主机查询自己的IP地址。这时候网络上的RARP服务器就会将发送端的IP地址用RARP Reply封包回应给查询者，这样查询主机就获得自己的IP地址了。</p>
<h2 id="为什么需要这个"><a href="#为什么需要这个" class="headerlink" title="为什么需要这个"></a>为什么需要这个</h2><p>数据包在物理链路上传输 以太网帧 需要目的地的物理地址（MAC）<br>通过ARP协议来获取同一个网络内的机器的IP地址和Mac的对应关系，为上层协议提供支持，因为上层协议使用IP地址进行通信。</p>
<ul>
<li>局域网内的IP地址（通过子网掩码计算）之间的通信，就可以理解为设备（MAC）对设备（MAC）之间的通信</li>
<li>跨局域网的通信就是设备(MAC)对 网关（MAC）之间的通信</li>
</ul>
<h2 id="ARP-数据包"><a href="#ARP-数据包" class="headerlink" title="ARP 数据包"></a>ARP 数据包</h2><p><strong>Wireshark 抓包</strong> </p>
<p>ARP 广播请求 （由192.168.1.88 发起的广播请求，询问谁的IP是192.168.1.1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4595	296.111634	Giga-Byt_18:04:4a	Broadcast	ARP	42	Who has 192.168.1.1? Tell 192.168.1.88</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内容如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Frame 4595: 42 bytes on wire (336 bits), 42 bytes captured (336 bits) on interface 0</span><br><span class="line">Ethernet II, Src: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a), Dst: Broadcast (ff:ff:ff:ff:ff:ff)</span><br><span class="line">    Destination: Broadcast (ff:ff:ff:ff:ff:ff)</span><br><span class="line">    Source: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Type: ARP (0x0806)</span><br><span class="line">Address Resolution Protocol (request)</span><br><span class="line">    Hardware type: Ethernet (1)</span><br><span class="line">    Protocol type: IPv4 (0x0800)</span><br><span class="line">    Hardware size: 6</span><br><span class="line">    Protocol size: 4</span><br><span class="line">    Opcode: request (1)</span><br><span class="line">    Sender MAC address: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Sender IP address: 192.168.1.88</span><br><span class="line">    Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00)</span><br><span class="line">    Target IP address: 192.168.1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ARP 应答 （192.168.1.1 直接应答 192.168.1.88，告知其Mac地址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4596	296.111872	NewH3CTe_95:65:a9	Giga-Byt_18:04:4a	ARP	60	192.168.1.1 is at 04:40:a9:95:65:a9</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内容如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Frame 4596: 60 bytes on wire (480 bits), 60 bytes captured (480 bits) on interface 0</span><br><span class="line">Ethernet II, Src: NewH3CTe_95:65:a9 (04:40:a9:95:65:a9), Dst: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Destination: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Source: NewH3CTe_95:65:a9 (04:40:a9:95:65:a9)</span><br><span class="line">    Type: ARP (0x0806)</span><br><span class="line">    Padding: 000000000000000000000000000000000000</span><br><span class="line">Address Resolution Protocol (reply)</span><br><span class="line">    Hardware type: Ethernet (1)</span><br><span class="line">    Protocol type: IPv4 (0x0800)</span><br><span class="line">    Hardware size: 6</span><br><span class="line">    Protocol size: 4</span><br><span class="line">    Opcode: reply (2)</span><br><span class="line">    Sender MAC address: NewH3CTe_95:65:a9 (04:40:a9:95:65:a9)</span><br><span class="line">    Sender IP address: 192.168.1.1</span><br><span class="line">    Target MAC address: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Target IP address: 192.168.1.88</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他收到该广播的机器判断【192.168.1.1】不是自己的IP，直接丢弃</p>
<h2 id="ARP-命令说明"><a href="#ARP-命令说明" class="headerlink" title="ARP 命令说明"></a>ARP 命令说明</h2><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">显示和修改地址解析协议(ARP)使用的“IP 到物理”地址转换表。</span><br><span class="line"></span><br><span class="line">ARP -s inet_addr eth_addr [if_addr]</span><br><span class="line">ARP -d inet_addr [if_addr]</span><br><span class="line">ARP -a [inet_addr] [-N if_addr] [-v]</span><br><span class="line"></span><br><span class="line">  -a            通过询问当前协议数据，显示当前 ARP 项。</span><br><span class="line">                如果指定 inet_addr，则只显示指定计算机</span><br><span class="line">                的 IP 地址和物理地址。如果不止一个网络</span><br><span class="line">                接口使用 ARP，则显示每个 ARP 表的项。</span><br><span class="line">  -g            与 -a 相同。</span><br><span class="line">  -v            在详细模式下显示当前 ARP 项。所有无效项</span><br><span class="line">                和环回接口上的项都将显示。</span><br><span class="line">  inet_addr     指定 Internet 地址。</span><br><span class="line">  -N if_addr    显示 if_addr 指定的网络接口的 ARP 项。</span><br><span class="line">  -d            删除 inet_addr 指定的主机。inet_addr 可</span><br><span class="line">                以是通配符 *，以删除所有主机。</span><br><span class="line">  -s            添加主机并且将 Internet 地址 inet_addr</span><br><span class="line">                与物理地址 eth_addr 相关联。物理地址是用</span><br><span class="line">                连字符分隔的 6 个十六进制字节。该项是永久的。</span><br><span class="line">  eth_addr      指定物理地址。</span><br><span class="line">  if_addr       如果存在，此项指定地址转换表应修改的接口</span><br><span class="line">                的 Internet 地址。如果不存在，则使用第一</span><br><span class="line">                个适用的接口。</span><br><span class="line">示例:</span><br><span class="line">  &gt; arp -s 157.55.85.212   00-aa-00-62-c6-09.... 添加静态项。</span><br><span class="line">  &gt; arp -a                                  .... 显示 ARP 表。</span><br></pre></td></tr></table></figure>

<h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># man arp</span><br><span class="line">ARP(8)                     Linux Programmer’s Manual                    ARP(8)</span><br><span class="line">NAME</span><br><span class="line">       arp - manipulate the system ARP cache</span><br><span class="line">SYNOPSIS</span><br><span class="line">       arp [-evn] [-H type] [-i if] -a [hostname]</span><br><span class="line">       arp [-v] [-i if] -d hostname [pub]</span><br><span class="line">       arp [-v] [-H type] [-i if] -s hostname hw_addr [temp]</span><br><span class="line">       arp [-v] [-H type] [-i if] -s hostname hw_addr [netmask nm] pub</span><br><span class="line">       arp [-v] [-H type] [-i if] -Ds hostname ifa [netmask nm] pub</span><br><span class="line">       arp [-vnD] [-H type] [-i if] -f [filename]</span><br><span class="line">NOTE</span><br><span class="line">       This program is obsolete. For replacement check ip neighbor.</span><br><span class="line">DESCRIPTION</span><br><span class="line">       Arp  manipulates the kernel’s ARP cache in various ways.  The primary options are clearing an address mapping entry and manually setting up one.  For debugging purposes, the arp pro-</span><br><span class="line">       gram also allows a complete dump of the ARP cache.</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>




<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="ping不存在的局域网机器"><a href="#ping不存在的局域网机器" class="headerlink" title="ping不存在的局域网机器"></a>ping不存在的局域网机器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cmd</span><br><span class="line">C:\Users\Administrator&gt;ping 192.168.1.111</span><br><span class="line"></span><br><span class="line">正在 Ping 192.168.1.111 具有 32 字节的数据:</span><br><span class="line">来自 192.168.1.88 的回复: 无法访问目标主机。</span><br><span class="line">来自 192.168.1.88 的回复: 无法访问目标主机。</span><br><span class="line">来自 192.168.1.88 的回复: 无法访问目标主机。</span><br><span class="line">来自 192.168.1.88 的回复: 无法访问目标主机。</span><br><span class="line"></span><br><span class="line">192.168.1.111 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br></pre></td></tr></table></figure>
<h4 id="wireshark-抓包"><a href="#wireshark-抓包" class="headerlink" title="wireshark 抓包"></a>wireshark 抓包</h4><blockquote>
<p>过滤条件：arp.dst.proto_ipv4&#x3D;&#x3D;192.168.1.111 or icmp</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2910	206.611909	Giga-Byt_18:04:4a	Broadcast	ARP	42	Who has 192.168.1.111? Tell 192.168.1.88</span><br><span class="line">2917	207.570302	Giga-Byt_18:04:4a	Broadcast	ARP	42	Who has 192.168.1.111? Tell 192.168.1.88</span><br><span class="line">2924	208.570334	Giga-Byt_18:04:4a	Broadcast	ARP	42	Who has 192.168.1.111? Tell 192.168.1.88</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>只有arp请求</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>可以看到只会发送ARP请求，且ARP请求没有获得响应，此时无法获取ping的目的地，故不会发送ping（ICMP）请求<br>且错误显示为：<strong>“无法访问目标主机”</strong></p>
<h3 id="添加静态arp映射后再ping"><a href="#添加静态arp映射后再ping" class="headerlink" title="添加静态arp映射后再ping"></a>添加静态arp映射后再ping</h3><p>先添加IP对MAC的映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -s 192.168.1.111 00-2b-3c-f0-ff-ff</span><br></pre></td></tr></table></figure>
<p>用 arp -a 查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;arp -a</span><br><span class="line"></span><br><span class="line">接口: 192.168.1.88 --- 0xb</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.1.1           04-40-a9-95-65-a9     动态</span><br><span class="line">  192.168.1.111          00-2b-3c-f0-ff-ff     静态</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>ping 测试 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ping 192.168.1.111</span><br><span class="line"></span><br><span class="line">正在 Ping 192.168.1.111 具有 32 字节的数据:</span><br><span class="line">请求超时。</span><br><span class="line">请求超时。</span><br><span class="line">请求超时。</span><br><span class="line">请求超时。</span><br><span class="line"></span><br><span class="line">192.168.1.111 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 0，丢失 = 4 (100% 丢失)，</span><br></pre></td></tr></table></figure>

<h4 id="wireshark-抓包-1"><a href="#wireshark-抓包-1" class="headerlink" title="wireshark 抓包"></a>wireshark 抓包</h4><blockquote>
<p>过滤条件：arp.dst.proto_ipv4&#x3D;&#x3D;192.168.1.111 or icmp</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">275	19.179418	192.168.1.88	192.168.1.111	ICMP	74	Echo (ping) request  id=0x0001, seq=26/6656, ttl=64 (no response found!)</span><br><span class="line">315	23.681918	192.168.1.88	192.168.1.111	ICMP	74	Echo (ping) request  id=0x0001, seq=27/6912, ttl=64 (no response found!)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>只有ping</p>
<p><strong>数据报详情：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Frame 315: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface 0</span><br><span class="line">Ethernet II, Src: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a), Dst: 00:2b:3c:f0:ff:ff (00:2b:3c:f0:ff:ff)</span><br><span class="line">    Destination: 00:2b:3c:f0:ff:ff (00:2b:3c:f0:ff:ff)</span><br><span class="line">    Source: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Type: IPv4 (0x0800)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.88, Dst: 192.168.1.111</span><br><span class="line">Internet Control Message Protocol</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>当本地的Arp缓存中有IP地址和Mac地址的对应关系时，会直接往目标地址发送数据报，从以太网帧中可以看到目的地Mac就是我们设置的Mac。<br>此时不会再发送ARP请求，直接发送了Ping请求，且错误显示为：<strong>“请求超时”</strong></p>
<h3 id="修改网关Mac，让本机无法上网"><a href="#修改网关Mac，让本机无法上网" class="headerlink" title="修改网关Mac，让本机无法上网"></a>修改网关Mac，让本机无法上网</h3><h4 id="找网关地址"><a href="#找网关地址" class="headerlink" title="找网关地址"></a>找网关地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;ipconfig</span><br><span class="line"></span><br><span class="line">以太网适配器 本地连接:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.1.88</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . : 192.168.1.1</span><br></pre></td></tr></table></figure>

<h4 id="查网关真实的Mac地址"><a href="#查网关真实的Mac地址" class="headerlink" title="查网关真实的Mac地址"></a>查网关真实的Mac地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;arp -a | findstr 192.168.1.1</span><br><span class="line">  192.168.1.1           04-40-a9-95-66-a9     动态</span><br><span class="line">  192.168.1.111         00-2b-3c-f0-ff-ff     静态</span><br></pre></td></tr></table></figure>

<h4 id="修改本地arp缓存中的网关Mac地址"><a href="#修改本地arp缓存中的网关Mac地址" class="headerlink" title="修改本地arp缓存中的网关Mac地址"></a>修改本地arp缓存中的网关Mac地址</h4><p>这里修改 192.168.1.1 的Mac地址<br><strong>arp 命令修改失败：拒绝访问</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arp -d 192.168.1.1</span><br><span class="line">arp -s 192.168.1.1 00-2b-3c-f0-ff-f1 192.168.1.88</span><br><span class="line">ARP 项添加失败: 拒绝访问。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改用netsh命令修改 </p>
<ol>
<li>先找本地网卡的 Idx，这里是：11<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netsh i i show in</span><br><span class="line"></span><br><span class="line">Idx     Met         MTU          状态                名称</span><br><span class="line">---  ----------  ----------  ------------  ---------------------------</span><br><span class="line">  1          50  4294967295  connected     Loopback Pseudo-Interface 1</span><br><span class="line"> 11          10        1500  connected     本地连接</span><br><span class="line"> 16          30        1500  connected     Npcap Loopback Adapter</span><br></pre></td></tr></table></figure></li>
<li>使用如下命令修改本地Mac地址缓存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netsh -c &quot;i i&quot; add neighbors 11 &quot;网关IP&quot; &quot;Mac地址&quot;  -- 这里11是idx号。</span><br><span class="line"></span><br><span class="line">netsh -c &quot;i i&quot; add neighbors 11 &quot;192.168.1.1&quot; &quot;00-2b-3c-f0-ff-f1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>验证修改结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;arp -a</span><br><span class="line"></span><br><span class="line">接口: 192.168.1.88 --- 0xb</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.1.1           00-2b-3c-f0-ff-f1     静态</span><br><span class="line">  192.168.1.171         d4-5d-df-01-32-f0     动态</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="导致的结果是本机不能再上网了，但局域网访问正常"><a href="#导致的结果是本机不能再上网了，但局域网访问正常" class="headerlink" title="导致的结果是本机不能再上网了，但局域网访问正常"></a>导致的结果是本机不能再上网了，但局域网访问正常</h4><p>比如在浏览器中访问百度</p>
<p>使用wireshar 抓包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 这里先进行DNS解析</span><br><span class="line"></span><br><span class="line">6	0.783394	192.168.1.88	114.114.114.114	DNS	73	Standard query 0x341b A www.baidu.com</span><br><span class="line"></span><br><span class="line"># 可以看到直接将数据包发送到了我们上面配置的假Mac地址： 00-2b-3c-f0-ff-f1 </span><br><span class="line"></span><br><span class="line">Frame 6: 73 bytes on wire (584 bits), 73 bytes captured (584 bits) on interface 0</span><br><span class="line">Ethernet II, Src: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a), Dst: 00:2b:3c:f0:ff:f1 (00:2b:3c:f0:ff:f1)</span><br><span class="line">    Destination: 00:2b:3c:f0:ff:f1 (00:2b:3c:f0:ff:f1)</span><br><span class="line">    Source: Giga-Byt_18:04:4a (e0:d5:5e:18:04:4a)</span><br><span class="line">    Type: IPv4 (0x0800)</span><br><span class="line">Internet Protocol Version 4, Src: 192.168.1.88, Dst: 114.114.114.114</span><br><span class="line">User Datagram Protocol, Src Port: 64752, Dst Port: 53</span><br><span class="line">Domain Name System (query)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="还原网关对应的mac地址"><a href="#还原网关对应的mac地址" class="headerlink" title="还原网关对应的mac地址"></a>还原网关对应的mac地址</h4><p>使用netsh 命令设置之后，再用 <code>arp -d 192.168.1.1</code>命令删除，在重启之前是可以上网的，下次重启网关的mac地址还将是错误的</p>
<h5 id="查看："><a href="#查看：" class="headerlink" title="查看："></a>查看：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">netsh -c &quot;i i&quot; show neighbors 11</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;netsh -c &quot;i i&quot; show neighbors 11</span><br><span class="line"></span><br><span class="line">接口 11: 本地连接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Internet 地址                                 物理地址           类型</span><br><span class="line">--------------------------------------------  -----------------  -----------</span><br><span class="line">192.168.1.1                                   00-2b-3c-f0-ff-f1  永久</span><br><span class="line">192.168.1.11                                  00-0c-29-47-fd-8d  停滞</span><br><span class="line">192.168.1.63                                  00-00-00-00-00-00  无法访问</span><br><span class="line">192.168.1.92                                  00-00-00-00-00-00  无法访问</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h5 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh -c &quot;i i&quot; delete neighbors 11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要使用上面的命令删除，完了之后就会变成 “可以访问”</p>
<hr>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><p>ARP欺骗可以分成两种情况：</p>
<h3 id="一、欺骗路由器"><a href="#一、欺骗路由器" class="headerlink" title="一、欺骗路由器"></a>一、欺骗路由器</h3><p>发送一系列错误的内网MAC地址给路由器，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。</p>
<h3 id="二、欺骗局域网内的机器"><a href="#二、欺骗局域网内的机器" class="headerlink" title="二、欺骗局域网内的机器"></a>二、欺骗局域网内的机器</h3><p>不停发送错误的网关Mac到局域网的机器中，让局域网内的机器建立错误的绑定关系，让局域网内的机器不能正确的将数据包发送到网关设备，导致PC不能上网。</p>
<h2 id="ARP欺骗测试"><a href="#ARP欺骗测试" class="headerlink" title="ARP欺骗测试"></a>ARP欺骗测试</h2><h3 id="使用发包工具"><a href="#使用发包工具" class="headerlink" title="使用发包工具"></a>使用发包工具</h3><p>……<br>有时间再试试<br>……</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="获取局域网某IP对应的Mac"><a href="#获取局域网某IP对应的Mac" class="headerlink" title="获取局域网某IP对应的Mac"></a>获取局域网某IP对应的Mac</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; arping 192.168.1.88</span><br><span class="line">ARPING 192.168.1.88 from 192.168.1.216 eth0</span><br><span class="line">Unicast reply from 192.168.1.88 [E0:D5:5E:18:04:4A]  1.767ms</span><br><span class="line">Unicast reply from 192.168.1.88 [E0:D5:5E:18:04:4A]  1.312ms</span><br><span class="line">Unicast reply from 192.168.1.88 [E0:D5:5E:18:04:4A]  1.635ms</span><br></pre></td></tr></table></figure>

<h3 id="测试局域网个中某个IP是否被占用"><a href="#测试局域网个中某个IP是否被占用" class="headerlink" title="测试局域网个中某个IP是否被占用"></a>测试局域网个中某个IP是否被占用</h3><p>返回值为1表示已被使用，0表示没有被使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@RD-WEBSERVER-03 ~]# arping -D 192.168.1.163 -w 5  </span><br><span class="line">ARPING 192.168.1.163 from 0.0.0.0 eth0</span><br><span class="line">Sent 6 probes (6 broadcast(s))</span><br><span class="line">Received 0 response(s)</span><br><span class="line"></span><br><span class="line">[root@RD-WEBSERVER-03 ~]# arping -D 192.168.1.88 -w 5   </span><br><span class="line">ARPING 192.168.1.88 from 0.0.0.0 eth0</span><br><span class="line">Unicast reply from 192.168.1.88 [E0:D5:5E:18:04:4A]  1.848ms</span><br><span class="line">Sent 1 probes (1 broadcast(s))</span><br><span class="line">Received 1 response(s)</span><br></pre></td></tr></table></figure>


<h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><p>过滤目的地址<br>arp.dst.proto_ipv4&#x3D;&#x3D;192.168.1.214</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/%E8%B7%AF%E7%94%B1%E5%99%A8&%E5%85%89%E7%8C%AB/%E5%85%89%E7%8C%AB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AEVLAN%E7%9C%8BIPTV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/%E8%B7%AF%E7%94%B1%E5%99%A8&%E5%85%89%E7%8C%AB/%E5%85%89%E7%8C%AB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AEVLAN%E7%9C%8BIPTV/" class="post-title-link" itemprop="url">光猫和路由器配置VLAN看IPTV</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-25 23:41:00" itemprop="dateCreated datePublished" datetime="2020-05-25T23:41:00+08:00">2020-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">硬件与物联网</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB/" itemprop="url" rel="index"><span itemprop="name">路由器&光猫</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>路由器型号 小米R2D</strong></p>
<h3 id="路由器端口"><a href="#路由器端口" class="headerlink" title="路由器端口"></a>路由器端口</h3><p>wan 口 编号：4<br>lan 口 编号：0 2 3<br>CPU端口： 5 </p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://openwrt.org/zh-cn/doc/uci/network">https://openwrt.org/zh-cn/doc/uci/network</a><br><a target="_blank" rel="noopener" href="https://openwrt.org/docs/guide-user/network/vlan/switch">https://openwrt.org/docs/guide-user/network/vlan/switch</a><br><a target="_blank" rel="noopener" href="https://openwrt.org/zh/docs/guide-user/network/vlan/switch_configuration">https://openwrt.org/zh/docs/guide-user/network/vlan/switch_configuration</a></p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>一般来说，0、1、2、3是路由器LAN口，4是路由器WAN口，5表示CPU，而5*表示这个接口是trunk</p>
<p>使用“ *”和“ u”分别表示PVID和未标记的端口（因为它们具有隐式标记的CPU端口，因此需要使用“ u”来取消标记） ）。</p>
<p>在端口上收到的未标记的数据包将被定向到默认端口VLAN（通常称为PVID）。需要一个单独的config switch_port部分来设置默认端口VLAN<br>虚拟局域网。</p>
<p>小米是定制的openwrt系统，采用的是博通闭源驱动，因此vlan设置不能采用openwrt的设定方式，必须采用类似于dd-wr闭源驱动nvram set方式才能使vlan生效。具体是修改&#x2F;etc&#x2F;config&#x2F;misc，将相应的vlanXports参数修改成&#x2F;etc&#x2F;config&#x2F;network里面的port端口号，甚至需要修改&#x2F;etc&#x2F;init.d&#x2F;boot里面的nvram vlan配置参数，然后reboot，重启，新的vlan端口充当wan才能生效</p>
<hr>
<h4 id="原来的"><a href="#原来的" class="headerlink" title="原来的"></a>原来的</h4><table>
<thead>
<tr>
<th>端口编号</th>
<th>5</th>
<th>0</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物理接口</td>
<td>CPU (eth0)</td>
<td>LAN 1</td>
<td>LAN 2</td>
<td>LAN 3</td>
<td>WAN</td>
</tr>
<tr>
<td>VLAN ID 1 (eth0_1)</td>
<td>已标记</td>
<td>未标记</td>
<td>未标记</td>
<td>未标记</td>
<td>禁用</td>
</tr>
<tr>
<td>VLAN ID 2 (eth0_2)</td>
<td>已标记</td>
<td>禁用</td>
<td>禁用</td>
<td>禁用</td>
<td>未标记</td>
</tr>
</tbody></table>
<h4 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h4><table>
<thead>
<tr>
<th>端口编号</th>
<th>5</th>
<th>0</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物理接口</td>
<td>CPU (eth0)</td>
<td>LAN 1</td>
<td>LAN 2</td>
<td>LAN 3</td>
<td>WAN</td>
</tr>
<tr>
<td>VLAN ID 1 (eth0_1)</td>
<td>已标记</td>
<td>未标记</td>
<td>未标记</td>
<td>禁用</td>
<td>禁用</td>
</tr>
<tr>
<td>VLAN ID 2 (eth0_2)</td>
<td>已标记</td>
<td>禁用</td>
<td>禁用</td>
<td>禁用</td>
<td>已标记（Internet）</td>
</tr>
<tr>
<td>VLAN ID 3 (eth0_3)</td>
<td>已标记</td>
<td>禁用</td>
<td>禁用</td>
<td>未标记</td>
<td>已标记 （IPTV）</td>
</tr>
</tbody></table>
<p><strong>LAN3口直接连接机顶盒</strong></p>
<blockquote>
<p>这个没有测试，因为下面这个更简单</p>
</blockquote>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="使用robocfg-配置VLAN"><a href="#使用robocfg-配置VLAN" class="headerlink" title="使用robocfg 配置VLAN"></a>使用robocfg 配置VLAN</h2><blockquote>
<p>上面配置比较麻烦，还是下载一个 robocfg工具，通过工具来进行配置</p>
</blockquote>
<p>下载地址：<br><a target="_blank" rel="noopener" href="https://www.right.com.cn/forum/forum.php?mod=viewthread&tid=334441&page=1">https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=334441&amp;page=1</a></p>
<blockquote>
<p>就是按照这个弄的</p>
</blockquote>
<h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><p>Broadcom BCM5325&#x2F;535x&#x2F;536x&#x2F;5311x switch configuration utility</p>
<p>其实这个CPU是 CPU BCM4709C</p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>先弄到路由器的硬盘上</p>
<p>为了之后使用方便，再复制文件到&#x2F;usr&#x2F;bin目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /userdisk/data/ftp/robocfg /usr/bin/</span><br><span class="line">cp: can&#x27;t create &#x27;/usr/bin/robocfg&#x27;: Read-only file system</span><br></pre></td></tr></table></figure>
<p>报错，提示是只读的</p>
<p>以读写方式重新挂载根目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount rw /</span><br></pre></td></tr></table></figure>

<p>然后再复制就可以了</p>
<p>加上执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x robocfg</span><br></pre></td></tr></table></figure>


<h3 id="查看现有VLAN配置"><a href="#查看现有VLAN配置" class="headerlink" title="查看现有VLAN配置"></a>查看现有VLAN配置</h3><p>robocfg show</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ./robocfg show</span><br><span class="line">Switch: enabled </span><br><span class="line">Port 0:   DOWN enabled stp: none vlan: 1 jumbo: off mac: 00:00:00:00:00:00</span><br><span class="line">Port 1:   DOWN enabled stp: none vlan: 1 jumbo: off mac: 00:00:00:00:00:00</span><br><span class="line">Port 2: 1000FD enabled stp: none vlan: 1 jumbo: off mac: ec:00:00:d4:00:xx</span><br><span class="line">Port 3:   DOWN enabled stp: none vlan: 1 jumbo: off mac: d4:00:00:c1:00:xx</span><br><span class="line">Port 4: 1000FD enabled stp: none vlan: 2 jumbo: off mac: 00:00:01:00:00:xx</span><br><span class="line">Port 8:   DOWN enabled stp: none vlan: 1 jumbo: off mac: 00:00:00:00:00:00</span><br><span class="line">VLANs: BCM5301x enabled mac_check mac_hash</span><br><span class="line">   1: vlan1: 0 2 3 5t</span><br><span class="line">   2: vlan2: 4 5t</span><br></pre></td></tr></table></figure>

<h3 id="重新配置VLAN"><a href="#重新配置VLAN" class="headerlink" title="重新配置VLAN"></a>重新配置VLAN</h3><p>多插拔两次就可以确定 物理网卡 与 port 0 1 2 3 4 的对应关系了</p>
<table>
<thead>
<tr>
<th>Port</th>
<th>物理端口</th>
</tr>
</thead>
<tbody><tr>
<td>Port 0</td>
<td>LAN 口 1</td>
</tr>
<tr>
<td>Port 2</td>
<td>LAN 口 2</td>
</tr>
<tr>
<td>Port 3</td>
<td>LAN 口 3</td>
</tr>
<tr>
<td>Port 4</td>
<td>WAN 口</td>
</tr>
<tr>
<td>Port 5</td>
<td>CPU端口</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robocfg vlan 3 ports &quot;3 4t&quot;</span><br></pre></td></tr></table></figure>

<p>配置之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@XiaoQiang:~# robocfg vlan 3 ports &quot;3 4t&quot;</span><br><span class="line">root@XiaoQiang:~# robocfg show</span><br><span class="line">Switch: enabled </span><br><span class="line">Port 0: 1000FD enabled stp: none vlan: 1 jumbo: off mac: xx:xx:xx:xx:40:75</span><br><span class="line">Port 1:   DOWN enabled stp: none vlan: 1 jumbo: off mac: 00:00:00:00:00:00</span><br><span class="line">Port 2:   DOWN enabled stp: none vlan: 1 jumbo: off mac: xx:xx:xx:xx:40:75</span><br><span class="line">Port 3:   DOWN enabled stp: none vlan: 3 jumbo: off mac: xx:xx:xx:xx:d0:4f</span><br><span class="line">Port 4: 1000FD enabled stp: none vlan: 2 jumbo: off mac: 00:xx:xx:xx:xx:58</span><br><span class="line">Port 8:   DOWN enabled stp: none vlan: 1 jumbo: off mac: 00:00:00:00:00:00</span><br><span class="line">VLANs: BCM5301x enabled mac_check mac_hash</span><br><span class="line">   1: vlan1: 0 2 3 5t</span><br><span class="line">   2: vlan2: 4 5t</span><br><span class="line">   3: vlan3: 3 4t</span><br></pre></td></tr></table></figure>


<h3 id="光猫配置"><a href="#光猫配置" class="headerlink" title="光猫配置"></a>光猫配置</h3><p>取消 Internet 和 IPTV 连接的端口绑定，使用VLAN绑定</p>
<p>默认的 Internet 是没有VLAN的，IPTV默认有两个VLAN：45 和 47 </p>
<h4 id="配置VLAN绑定"><a href="#配置VLAN绑定" class="headerlink" title="配置VLAN绑定"></a>配置VLAN绑定</h4><p>用户侧Vlan ID 为上面定义的 3，Wan口Vlan ID 就填写IPTV的Vlan ID</p>
<blockquote>
<p>选千兆口</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>用户侧Vlan</th>
<th>WAN侧Vlan</th>
</tr>
</thead>
<tbody><tr>
<td>IPTV 单播</td>
<td>3</td>
<td>45</td>
</tr>
<tr>
<td>IPTV 组播</td>
<td>3</td>
<td>47</td>
</tr>
</tbody></table>
<h3 id="开机自动执行"><a href="#开机自动执行" class="headerlink" title="开机自动执行"></a>开机自动执行</h3><p>将上面的命令写入 &#x2F;etc&#x2F;rc.local 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">robocfg vlan 3 ports &quot;3 4t&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>


<h3 id="路由器连接光猫"><a href="#路由器连接光猫" class="headerlink" title="路由器连接光猫"></a>路由器连接光猫</h3><p>将路由器的3号lan口与机顶盒用网线连接即可</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看4K 高清不卡顿，比wifi稳定，wifi卡是因为干扰太多，弱电箱的位置不好，弱电箱有金属屏蔽了信号，导致看4K高清时偶尔会卡顿，wifi的带宽其实是足够了，机顶盒的网口也是百兆的，wifi还有300兆</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B5%81%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B5%81%E8%BD%AC/" class="post-title-link" itemprop="url">网络通信过程中的数据包流转</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-24T00:00:00+08:00">2020-05-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络与安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="网络通信过程中的数据包流转"><a href="#网络通信过程中的数据包流转" class="headerlink" title="网络通信过程中的数据包流转"></a>网络通信过程中的数据包流转</h2><blockquote>
<p>资料整理自网络的各个地方</p>
</blockquote>
<p>首先 我碰到了一个问题，一个数据包从我们的电脑上，经过层层的交换机、路由器到达目标服务器的过程中，数据包会有哪些改动，是如何一步步传递过去又是如何返回回来的？</p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211729064.png"></p>
<p>先需要了解一些基本的概念</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="OSI七层协议模型"><a href="#OSI七层协议模型" class="headerlink" title="OSI七层协议模型"></a>OSI七层协议模型</h4><p>OSI（Open System Interconnection）开放系统互连参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211729432.png"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>DHCP · DNS · FTP · Gopher ·GTP · HTTP · IMAP4 · IRC · NNTP · NTP · POP3 · RPC · RTCP · RTP ·RTSP · SIP · SMTP ·SNMP · SSH · SDP · SOAP .STUN. SSDP · TELNET · XMPP<br>表示层<br>HTTP&#x2F;HTML · FTP · Telnet · ASN.1（具有表示层功能）</p>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><p>ADSP ·ASP ·H.245·ISO-SP ·iSNS ·NetBIOS ·PAP ·RPC·<br>RTCP ·SMPP ·SCP ·SSH ·ZIP ·SDP（具有会话层功能）</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>TCP · UDP · TLS · DCCP · SCTP ·RSVP · PPTP</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>IP (IPv4 · IPv6) · ICMP · ICMPv6 · IGMP ·IS-IS · IPsec · BGP · RIP · OSPF ·ARP · RARP</p>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>Wi-Fi(IEEE 802.11) · WiMAX(IEEE 802.16) ·ATM · DTM · 令牌环 · 以太网路 ·<br>FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN ·STP</p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>以太网路卡 · 调制解调器 · 电力线通信(PLC) · SONET&#x2F;SDH（光同步数字传输网）<br>G.709（光传输网络） · 光导纤维 · 同轴电缆 · 双绞线</p>
<h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><p>TCP&#x2F;IP协议栈是美国国防部高级研究计划局计算机网（ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。　　</p>
<p>ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的TCP&#x2F;IP协议栈获得了更为广泛的应用。</p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211731251.png"></p>
<h5 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h5><ul>
<li>· DHCP(动态主机分配协议)</li>
<li>· DNS (域名解析）</li>
<li>· FTP（File Transfer Protocol）文件传输协议</li>
<li>· Gopher （英文原义：The Internet Gopher Protocol 中文释义：（RFC-1436）网际Gopher协议）</li>
<li>· HTTP （Hypertext Transfer Protocol）超文本传输协议</li>
<li>· IMAP4 (Internet Message Access Protocol 4) 即 Internet信息访问协议的第4版本</li>
<li>· IRC （Internet Relay Chat ）网络聊天协议</li>
<li>· NNTP （Network News Transport Protocol）RFC-977）网络新闻传输协议</li>
<li>· XMPP 可扩展消息处理现场协议</li>
<li>· POP3 (Post Office Protocol 3)即邮局协议的第3个版本</li>
<li>· SIP 信令控制协议</li>
<li>· SMTP （Simple Mail Transfer Protocol）即简单邮件传输协议</li>
<li>· SNMP (Simple Network Management Protocol,简单网络管理协议)</li>
<li>· SSH （Secure Shell）安全外壳协议</li>
<li>. SSL: 安全套接字层协议；</li>
<li>· TELNET 远程登录协议</li>
<li>· RPC （Remote Procedure Call Protocol）（RFC-1831）远程过程调用协议</li>
<li>· RTCP （RTP Control Protocol）RTP 控制协议</li>
<li>· RTSP （Real Time Streaming Protocol）实时流传输协议</li>
<li>· TLS （Transport Layer Security Protocol）传输层安全协议</li>
<li>· SDP( Session Description Protocol）会话描述协议</li>
<li>· SOAP （Simple Object Access Protocol）简单对象访问协议</li>
<li>· GTP 通用数据传输平台</li>
<li>· STUN （Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议</li>
<li>· NTP （Network Time Protocol）网络校时协议</li>
</ul>
<h5 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h5><ul>
<li>·TCP（Transmission Control Protocol）传输控制协议</li>
<li>· UDP (User Datagram Protocol）用户数据报协议</li>
<li>· DCCP （Datagram Congestion Control Protocol）数据报拥塞控制协议</li>
<li>· SCTP（STREAM CONTROL TRANSMISSION PROTOCOL）流控制传输协议</li>
<li>· RTP(Real-time Transport Protocol或简写RTP）实时传送协议</li>
<li>· RSVP （Resource ReSer Vation Protocol）资源预留协议</li>
<li>· PPTP ( Point to Point Tunneling Protocol）点对点隧道协议</li>
</ul>
<h5 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h5><ul>
<li>·IP(IPv4 · IPv6) Internet Protocol（网络之间互连的协议）</li>
<li>·ARP : Address Resolution Protocol即地址解析协议，实现通过IP地址得知其物理地址。</li>
<li>·RARP :Reverse Address Resolution Protocol - 反向地址转换协议允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。</li>
<li>·ICMP :（Internet Control Message - Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器- 之间传递控制消息。</li>
<li>·ICMPv6:</li>
<li>·IGMP :Internet 组管理协议（IGMP）是因特网协议家族中的一个组播协议，用于IP - 主机向任一个直接相邻的路由器报告他们的组成员情况。</li>
<li>·RIP : 路由信息协议（RIP）是一种在网关与主机之间交换路由选择信息的标准。</li>
<li>·OSPF : (Open Shortest Path First开放式最短路径优先).</li>
<li>·BGP :（Border Gateway Protocol - ）边界网关协议，用来连接Internet上独立系统的路由选择协议</li>
<li>·IS-IS:（Intermediate System to Intermediate System Routing - Protocol）中间系统到中间系统的路由选择协议.</li>
<li>·IPsec:“Internet 协议安全性”是一种开放标准的框架结构，通过使用加密的安全服务以确保- 在Internet 协议 (IP) 网络上进行保密而安全的通讯。</li>
</ul>
<h5 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>802.11 · 802.16 · Wi-Fi · WiMAX · ATM · DTM · 令牌环 · 以太网 · FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN
　　</p>
<h5 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h5><p>以太网物理层 · 调制解调器 · PLC · SONET&#x2F;SDH · G.709 · 光导纤维 · 同轴电缆 · 双绞线</p>
<h3 id="OSI七层和TCP-IP四层的关系"><a href="#OSI七层和TCP-IP四层的关系" class="headerlink" title="OSI七层和TCP&#x2F;IP四层的关系"></a>OSI七层和TCP&#x2F;IP四层的关系</h3><ol>
<li>OSI引进了服务、接口、协议、分层的概念，TCP&#x2F;IP借鉴了OSI的这些概念建立TCP&#x2F;IP模型。</li>
<li>OSI先有模型，后有协议，先有标准，后进行实践；而TCP&#x2F;IP则相反，先有协议和应用，再提出了模型，且是参照OSI模型。</li>
<li>OSI是一种理论下的模型，而TCP&#x2F;IP已经被广泛应用，称为网络互联实施上的标准。</li>
</ol>
<h3 id="数据包的封装与解析"><a href="#数据包的封装与解析" class="headerlink" title="数据包的封装与解析"></a>数据包的封装与解析</h3><h4 id="封包"><a href="#封包" class="headerlink" title="封包"></a>封包</h4><p>应用程序产生并发送数据，数据经过层层包装，最后数据将封装成以太网帧，再从链路中发送出去。<br>通信过程中，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）</p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211736437.png"></p>
<h4 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h4><p>数据包到达目标机器后经过相反的过程，最终被目标程序接收</p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211736805.png"></p>
<h3 id="各层的数据报文结构"><a href="#各层的数据报文结构" class="headerlink" title="各层的数据报文结构"></a>各层的数据报文结构</h3><h4 id="TCP数据报"><a href="#TCP数据报" class="headerlink" title="TCP数据报"></a>TCP数据报</h4><p><img src="https://img.wangwen135.top:23456/2023/06/202306211737955.png"></p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211737508.png"></p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211737511.png"></p>
<h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><p><img src="https://img.wangwen135.top:23456/2023/06/202306211737666.png"></p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211737711.png"></p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211738219.png"></p>
<h4 id="以太网数据帧"><a href="#以太网数据帧" class="headerlink" title="以太网数据帧"></a>以太网数据帧</h4><p><img src="https://img.wangwen135.top:23456/2023/06/202306211738312.png"></p>
<ul>
<li><strong>Preamble</strong>：前导码，序言：7byte或56bits的长度，为交替的0和1，来进行时钟同步。</li>
<li><strong>SFD</strong>：Start frame delimiter (SFD)帧开始符号. 该符号 (1 byte: 10101011)表示了下面就是数据了，不能继续用来时钟同步了。10101011与preamble的1结尾相连接，形成2个1作为标志。</li>
<li><strong>Destination address</strong> 和 <strong>source address</strong> 就是源mac和目的mac地址</li>
<li><strong>Type</strong> ：类型. 此字段定义包封装在其中的上层协议的框架。该协议可以是IP、ARP、OSPF等。</li>
<li><strong>Data</strong>：数据来源于上一层，大小应在46到1500byte之间，如果小于46，则会自动补0，反之需要分割</li>
<li><strong>CRC</strong>：错误检测：检测源和目的mac地址与数据的和，如果发现错误，则该帧丢弃。</li>
</ul>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211742666.png"></p>
<h5 id="Wireshark-抓包数据"><a href="#Wireshark-抓包数据" class="headerlink" title="Wireshark 抓包数据"></a>Wireshark 抓包数据</h5><p><img src="https://img.wangwen135.top:23456/2023/06/202306211743928.png"></p>
<h3 id="数据包的传输"><a href="#数据包的传输" class="headerlink" title="数据包的传输"></a>数据包的传输</h3><p><strong>传输示意图</strong></p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211752486.png"></p>
<h4 id="以太网帧在数据链路层传输"><a href="#以太网帧在数据链路层传输" class="headerlink" title="以太网帧在数据链路层传输"></a>以太网帧在数据链路层传输</h4><p><img src="https://img.wangwen135.top:23456/2023/06/202306211752366.png"></p>
<h4 id="TCP数据传输过程"><a href="#TCP数据传输过程" class="headerlink" title="TCP数据传输过程"></a>TCP数据传输过程</h4><p><img src="https://img.wangwen135.top:23456/2023/06/202306211753773.png"></p>
<h4 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h4><p><img src="https://img.wangwen135.top:23456/2023/06/202306211753049.png"></p>
<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p><img src="https://img.wangwen135.top:23456/2023/06/202306211754196.png"></p>
<ul>
<li>第一次握手：客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</li>
<li>第二次握手：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的ISN加1以.即X+1。</li>
<li>第三次握手：客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1。</li>
</ul>
<h5 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h5><p><img src="https://img.wangwen135.top:23456/2023/06/202306211755492.png"></p>
<ul>
<li>第一次挥手：客户端发送一个FIN，用来关闭服务端到Server的数据传送，客户端进入FIN_WAIT_1状态。</li>
<li>第二次挥手：服务端 收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态</li>
<li>第三次挥手：服务端发送一个FIN，用来关闭Server到Client的数据传送，服务端进入LAST_ACK状态。</li>
<li>第四次挥手：客服端收到FIN后，服务端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手</li>
</ul>
<h3 id="网络设备与网络结构"><a href="#网络设备与网络结构" class="headerlink" title="网络设备与网络结构"></a>网络设备与网络结构</h3><p>首先大概知道什么是交换机、路由器和网关设备等，以及常见的网络结构</p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>这里指以太网交换机，以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p>
<p>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p>
<p>交换机在端口上接受计算机发送过来的数据帧，根据帧头的目的MAC地址查找MAC地址表然后将该数据帧从对应端口上转发出去，从而实现数据交换。</p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>路由器是连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。</p>
<p>路由器又可以称之为网关设备。工作于OSI网络参考模型的第三层（即网络层），对不同的网络之间的数据包进行存储、分组转发处理，而数据在一个子网中传输到另一个子网中，可以通过路由器的路由功能进行处理。在网络通信中，路由器具有判断网络地址以及选择IP路径的作用，可以在多个网络环境中，构建灵活的链接系统，通过不同的数据分组以及介质访问方式对各个子网进行链接。路由器在操作中仅接受源站或者其他相关路由器传递的信息，是一种基于网络层的互联设备。</p>
<p>路由器只能根据具体的IP地址来转发数据，IP地址由网络地址和主机地址两部分组成。计算机之间的通信只能在具有相同网络地址的IP地址之间进行，如果想要与其他网段的计算机进行通信，则必须经过路由器转发出去。</p>
<p>路由器的多个端口可以连接多个网段，每个端口的IP地址的网络地址都必须与所连接的网段的网络地址一致。不同的端口它的网络地址是不同的，所对应的网段也是不同的，这样才能使各个网段中的主机通过自己网段的IP地址把数据发送到路由器上。</p>
<p>对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。</p>
<p>路由器的主要工作就是为经过路由器的每个数据帧寻找一条最佳传输路径，并将该数据有效地传送到目的站点。</p>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关(Gateway)又称网间连接器、协议转换器。默认网关在【网络层】上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。</p>
<p>【说明：由于历史的原因，许多有关TCP&#x2F;IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP！】</p>
<p>那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1<del>192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1</del>192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP&#x2F;IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机</p>
<p>只有设置好网关的IP地址，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>
<h4 id="网关和路由器的区别"><a href="#网关和路由器的区别" class="headerlink" title="网关和路由器的区别"></a>网关和路由器的区别</h4><p>首先‘网关’一个大概念，不具体特指一类产品，只要连接两个不同的网络的设备都可以叫网关；而‘路由器’么一般特指能够实现路由寻找和转发的特定类产品，路由器很显然能够实现网关的功能。</p>
<p>我们在PC上设置的默认网关是什么，默认网关事实上不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个默认的中转地址上面进行转发，也就是默认网关。这个网关可以在路由器上，可以在三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。</p>
<h4 id="家用路由器"><a href="#家用路由器" class="headerlink" title="家用路由器"></a>家用路由器</h4><p><strong>家用路由器 &#x3D; 路由器 + 防火墙 + 交换机  &#x3D; 防火墙 + 交换机 + NAT</strong></p>
<p><strong>防火墙</strong>：路由器在许多方面扮演着基本防火墙的角色，包括自动拒绝不属于网络内的计算机与外部世界之间正在进行的交换的一部分的传入数据。另一方面，如果来自未知地址的端口探测突然出现，你的路由器就会充当保镖，拒绝请求，有效地隐藏你的计算机。</p>
<p><strong>网关</strong>：家庭路由器还充当网络交换机。网络交换机是一种硬件，它可以促进内部网络上计算机之间的通信。如果没有交换功能，这些设备可以通过路由器与更大的互联网通信，但不能相互通信。</p>
<p><strong>NAT</strong>：我们都知道，一台家用路由器可以允许多台设备同时连接上网，那么当设备通过家用路由器向网络发送请求后，返回的响应到达路由器时，路由器必须要知道该响应对应的是哪台设备发送的请求。我们向网络供应商（ISP）申请网络访问权限时，ISP会给路由器分配一个公网ip，路由器内部的设备只能使用内网ip。NAT的作用就是实现公网&#x2F;内网ip以及端口的转换。为此，需要一张表，用于记录内外ip和端口的映射关系。<br>假设内网中有两台设备A和B，同时访问同一个外网ip的相同端口。那么在路由器处就会记录如下映射关系：</p>
<blockquote>
<p>（remote ip_r : port_r)–(local ip_a : a_port)<br>（remote ip_r : port_r)–(local ip_b : b_port)</p>
</blockquote>
<p>假设恰好a_port和b_port的值相同，那么来自远端的响应数据到达路由器时，路由器就无法确定该请求应该给A还是给B。对于这种情况，NAT采用一个三元组来进行区分：（remote ip_r : port_r)(nat port)(local ip_a : a_port)，即通过增加nat port来进行区分。当A和B请求到来时，为两个请求生成两个尚未使用的端口：a_port和b_port，并记录如下关系：</p>
<blockquote>
<p>（remote ip_r : port_r)(nat a_port)(local ip_a : same_port)<br>（remote ip_r : port_r)(nat b_port)(local ip_b : same_port)</p>
</blockquote>
<p>即当A请求到达路由器时，路由器将请求的源ip换成ISP分配的公网ip，并将源端口换成a_port；而当请求B到达路由器时，路由器将请求的源ip换成ISP分配的公网ip，并将源端口换成b_port。当A和B的请求返回时，根据返回的目的端口（返回的目的端口就是请求的源端口）是a_port还是b_port即可确定该将响应给A还是B。</p>
<h4 id="Modem"><a href="#Modem" class="headerlink" title="Modem"></a>Modem</h4><p>通过电话线上网的时代，我们通过猫来连接互联网。现在运营商都升级成了光纤了，所以原来的猫换成光猫。</p>
<h5 id="猫"><a href="#猫" class="headerlink" title="猫"></a>猫</h5><p>调制解调器（英文名Modem），俗称“猫”，是一种计算机硬件。</p>
<p>它能把计算机的数字信号翻译成可沿普通电话线传送的脉冲信号，而这些脉冲信号又可被线路另一端的另一个调制解调器接收，并译成计算机可懂的语言。<br>计算机内的信息是由“0”和“1”组成数字信号，而在电话线上传递的却只能是模拟电信号。于是，当两台计算机要通过电话线进行数据传输时，就需要一个设备负责数模的转换。</p>
<h5 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h5><p>光猫和上面说的猫也是一样的，只是将传输脉冲信号变成了传输光信号。</p>
<p>现在一般的光猫外形都是和无线路由器相似，并且光猫上的天线也是可以发射无线信号的，这种能够自带路由器功能的，并且还能内置wifi功能的光猫，是一种集合光猫和路由一体的机器。</p>
<p>目前，家庭上网基本上都实现了FTTH，也就是光纤入户。 宽带上网、IPTV、电话均通过一根光纤接入，实现了“三网融合”。</p>
<p>生活中，我们使用手电筒时，可以通过明暗的变化传递信息，光纤传输信息跟这个差不多。 </p>
<p>在网络世界里，只有0和1，数字信号不能直接变成光信号，需要将数字信号转换成电信号，比如1用高压表示，0用低压表示。将这些电信号输入到激光、二极管等光源，光源根据信号电压变化而发光，比如高电压发光亮，低电压发光暗。 光信号到达对端时，通过光敏元件根据光的亮度产生不同的电压，转换成电信号，最后将电信号转换成数字信号，这样我们就收到信号了。</p>
<p><img src="https://img.wangwen135.top:23456/2023/06/202306211803884.png"></p>
<h4 id="常见的网络结构"><a href="#常见的网络结构" class="headerlink" title="常见的网络结构"></a>常见的网络结构</h4><p>只是在网上随便找的示例</p>
<h5 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h5><p><img src="https://img.wangwen135.top:23456/note/2023/06/649bfc2b4cf1f.png" alt="1687944231217.png"></p>
<h5 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h5><p><img src="https://img.wangwen135.top:23456/note/2023/06/649bfc579689d.png" alt="1687944275543.png"></p>
<h5 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h5><p><img src="https://img.wangwen135.top:23456/note/2023/06/649bfc7e8c92a.png" alt="1687944314510.png"></p>
<h3 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h3><p>1、当发送的目的地在局域网时，通过IP和子网掩码可以判断，然后根据本地的（IP地址 - 物理地址）映射表（arp协议），就能找到目标的mac直接发送数据包了。</p>
<p>2、当发送的目标地不在局域网中时，数据包会发送到网关（一般就是路由器）</p>
<pre><code>1. 从内网发到公网的数据包，在经过网关后，利用NAT，会被转换成网关的MAC，IP层地址被替换成公网真实IP。网关处会有一个映射关系表，这样返回的数据就会根据此映射关系做相应数据转发。
2. 数据包在经过交换机时不会修改数据，直接转发。
3. 数据包在经过中间路由器之后 源mac 和 目标mac 都是要改变，源mac改成路由器出网卡的mac，目标mac改成下一跳的mac，当然还会重新计算以太网帧的CRC等
</code></pre>
<h4 id="NAT（网络地址转换）"><a href="#NAT（网络地址转换）" class="headerlink" title="NAT（网络地址转换）"></a>NAT（网络地址转换）</h4><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。</p>
<p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p>
<h4 id="NAT的几种实现方式"><a href="#NAT的几种实现方式" class="headerlink" title="NAT的几种实现方式"></a>NAT的几种实现方式</h4><p><strong>静态转换</strong>：是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p>
<p><strong>动态转换</strong>：是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<p>**端口多路复用（Port address Translation,PAT)**：是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<p><strong>ALG（Application Level Gateway）</strong>：即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。例如：对于FTP协议的PORT&#x2F;PASV命令、DNS协议的 “A” 和 “PTR” queries命令和部分ICMP消息类型等都需要相应的ALG来支持。</p>
<h4 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h4><p><strong>NAPT（Network Address Port Translation）</strong>，即网络地址端口转换，可将多个内部地址映射为一个合法公网地址，但以不同的协议端口号与不同的内部地址相对应，也就是&lt;内部地址+内部端口&gt;与&lt;外部地址+外部端口&gt;之间的转换。NAPT普遍用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT也被称为“多对一”的NAT，或者叫PAT（Port Address Translations，端口地址转换）、地址超载（address overloading）。</p>
<p>NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。NAPT算得上是一种较流行的NAT变体，通过转换TCP或UDP协议端口号以及地址来提供并发性。除了一对源和目的IP地址以外，这个表还包括一对源和目的协议端口号，以及NAT盒使用的一个协议端口号。</p>
<p>NAPT的主要优势在于，能够使用一个全球有效IP地址获得通用性。主要缺点在于其通信仅限于TCP或UDP。当所有通信都采用TCP或UDP，NAPT允许一台内部计算机访问多台外部计算机，并允许多台内部主机访问同一台外部计算机，相互之间不会发生冲突。</p>
<h4 id="内网上网方案"><a href="#内网上网方案" class="headerlink" title="内网上网方案"></a>内网上网方案</h4><p>内网实现上网的方案一般就是Nat 和 Proxy</p>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>查看地址解析协议(ARP)使用的“IP 到物理”地址转换表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;arp -a</span><br></pre></td></tr></table></figure>
<p>查路由表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;route print</span><br></pre></td></tr></table></figure>
<p>追踪路由</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;tracert baidu.com</span><br></pre></td></tr></table></figure>

<p>抓包<br>Wireshark</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangwen135.github.io/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/centos7%20%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="王某某">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王某某的笔记">
      <meta itemprop="description" content="这是一个使用 Hexo 构建的博客，用于分享我的编程经验和学习笔记。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 王某某的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/centos7%20%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84git/" class="post-title-link" itemprop="url">centos7 安装最新版本的git</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-21 16:10:00" itemprop="dateCreated datePublished" datetime="2020-05-21T16:10:00+08:00">2020-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">版本控制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>254</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-最新git源码下载地址："><a href="#1-最新git源码下载地址：" class="headerlink" title="1 最新git源码下载地址："></a>1 最新git源码下载地址：</h3><p><a target="_blank" rel="noopener" href="https://github.com/git/git/releases">https://github.com/git/git/releases</a><br><a target="_blank" rel="noopener" href="https://www.kernel.org/pub/software/scm/git/">https://www.kernel.org/pub/software/scm/git/</a><br>可以手动下载下来在上传到服务器上面</p>
<h3 id="2-移除旧版本git"><a href="#2-移除旧版本git" class="headerlink" title="2 移除旧版本git"></a>2 移除旧版本git</h3><p>centos自带Git，7.x版本自带git 1.8.3.1（应该是，也可能不是），<br>安装新版本之前需要使用yun remove git卸载（安装后卸载也可以）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Git ~]# git --version    ## 查看自带的版本</span><br><span class="line">git version 1.8.3.1</span><br><span class="line">[root@Git ~]# yum remove git   ## 移除原来的版本</span><br></pre></td></tr></table></figure>

<h3 id="3-安装所需软件包"><a href="#3-安装所需软件包" class="headerlink" title="3 安装所需软件包"></a>3 安装所需软件包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Git ~]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel </span><br><span class="line">[root@Git ~]# yum install gcc-c++ perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure>
<h3 id="4-下载-安装"><a href="#4-下载-安装" class="headerlink" title="4 下载&amp;安装"></a>4 下载&amp;安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Git ~]# cd /usr/src</span><br><span class="line">[root@Git ~]# wget https://www.kernel.org/pub/software/scm/git/git-2.7.3.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="5-解压"><a href="#5-解压" class="headerlink" title="5 解压"></a>5 解压</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Git ~]# tar xf git-2.7.3.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="6-配置编译安装"><a href="#6-配置编译安装" class="headerlink" title="6 配置编译安装"></a>6 配置编译安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Git ~]# cd git-2.7.3</span><br><span class="line">[root@Git ~]# make configure</span><br><span class="line">[root@Git ~]# ./configure --prefix=/usr/local/git ##配置目录</span><br><span class="line">[root@Git ~]# make profix=/usr/local/git</span><br><span class="line">[root@Git ~]# make install</span><br></pre></td></tr></table></figure>

<h3 id="7-加入环境变量"><a href="#7-加入环境变量" class="headerlink" title="7 加入环境变量"></a>7 加入环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Git ~]# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/profile</span><br><span class="line">[root@Git ~]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="8-检查版本"><a href="#8-检查版本" class="headerlink" title="8 检查版本"></a>8 检查版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Git git-2.7.3]# git --version </span><br><span class="line">git version 2.7.3</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">王某某</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">150k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  






  





</body>
</html>
